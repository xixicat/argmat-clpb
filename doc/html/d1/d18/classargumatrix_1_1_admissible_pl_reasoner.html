<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>argmat-clpb: argumatrix::AdmissiblePlReasoner Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../logo-small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">argmat-clpb
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d1/d18/classargumatrix_1_1_admissible_pl_reasoner.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="../../df/de7/classargumatrix_1_1_admissible_pl_reasoner-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">argumatrix::AdmissiblePlReasoner Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for argumatrix::AdmissiblePlReasoner:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../d1/d18/classargumatrix_1_1_admissible_pl_reasoner.png" usemap="#argumatrix::AdmissiblePlReasoner_map" alt=""/>
  <map id="argumatrix::AdmissiblePlReasoner_map" name="argumatrix::AdmissiblePlReasoner_map">
<area href="../../dd/d9a/classargumatrix_1_1_pl_reasoner.html" alt="argumatrix::PlReasoner" shape="rect" coords="0,56,202,80"/>
<area href="../../da/d89/classargumatrix_1_1_reasoner.html" alt="argumatrix::Reasoner" shape="rect" coords="0,0,202,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1043891a18cb737c295e0baf1ff493c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1043891a18cb737c295e0baf1ff493c6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AdmissiblePlReasoner</b> (const <a class="el" href="../../d1/d62/classargumatrix_1_1_dung_a_f.html">DungAF</a> &amp;daf, const string &amp;sm_task=&quot;AD&quot;, streambuf *osbuff=std::cout.rdbuf())</td></tr>
<tr class="separator:a1043891a18cb737c295e0baf1ff493c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ce5625c25c6828c9e20f9a5df6253b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d18/classargumatrix_1_1_admissible_pl_reasoner.html#a02ce5625c25c6828c9e20f9a5df6253b">task_EE</a> ()</td></tr>
<tr class="memdesc:a02ce5625c25c6828c9e20f9a5df6253b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print all extensions (with a vector of integers {0,1,2})  <a href="#a02ce5625c25c6828c9e20f9a5df6253b">More...</a><br /></td></tr>
<tr class="separator:a02ce5625c25c6828c9e20f9a5df6253b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d406a540effa66e01dc34a0e629887"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1d406a540effa66e01dc34a0e629887"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>task_EX</b> ()</td></tr>
<tr class="separator:af1d406a540effa66e01dc34a0e629887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a9a11fa7cdeb7e0278cf54ff40bf1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d18/classargumatrix_1_1_admissible_pl_reasoner.html#ad9a9a11fa7cdeb7e0278cf54ff40bf1e">task_EC</a> (const std::set&lt; string &gt; &amp;argset)</td></tr>
<tr class="memdesc:ad9a9a11fa7cdeb7e0278cf54ff40bf1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an ${AF}=&lt; {X}, {R}&gt;$ and an argument $s  {X}$ (respectively, a set of arguments $S {X}$), enumerate all sets $E {X}$ such that $E  {E}_(AF)$ and $s E$ (respectively, $S  E$).  <a href="#ad9a9a11fa7cdeb7e0278cf54ff40bf1e">More...</a><br /></td></tr>
<tr class="separator:ad9a9a11fa7cdeb7e0278cf54ff40bf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f647bb5cfb92172e5de80b6e07e9bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d18/classargumatrix_1_1_admissible_pl_reasoner.html#ad2f647bb5cfb92172e5de80b6e07e9bd">task_SC</a> (const std::set&lt; string &gt; &amp;argset)</td></tr>
<tr class="memdesc:ad2f647bb5cfb92172e5de80b6e07e9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an ${AF}=&lt; {X}, {R}&gt;$ and an argument $s  {X}$ (respectively, a set of arguments $S {X}$), enumerate some set $E {X}$ such that $E  {E}_(AF)$ and $s E$ (respectively, $S  E$).  <a href="#ad2f647bb5cfb92172e5de80b6e07e9bd">More...</a><br /></td></tr>
<tr class="separator:ad2f647bb5cfb92172e5de80b6e07e9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc14015ec60ef03ccc50651fca51ce4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d18/classargumatrix_1_1_admissible_pl_reasoner.html#abc14015ec60ef03ccc50651fca51ce4d">task_SE</a> ()</td></tr>
<tr class="memdesc:abc14015ec60ef03ccc50651fca51ce4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an ${AF}=&lt; {X}, {R}&gt;$, enumerate some set $E {X}$ that are in ${E}_(AF)$.  <a href="#abc14015ec60ef03ccc50651fca51ce4d">More...</a><br /></td></tr>
<tr class="separator:abc14015ec60ef03ccc50651fca51ce4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ee5219f0f3d62919e785fc358f86f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d18/classargumatrix_1_1_admissible_pl_reasoner.html#ab6ee5219f0f3d62919e785fc358f86f4">findAllExts</a> ()</td></tr>
<tr class="separator:ab6ee5219f0f3d62919e785fc358f86f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad038b5d309cbc354de30b0c9e872a3e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d18/classargumatrix_1_1_admissible_pl_reasoner.html#ad038b5d309cbc354de30b0c9e872a3e0">task_DE</a> (const std::set&lt; string &gt; &amp;argset)</td></tr>
<tr class="memdesc:ad038b5d309cbc354de30b0c9e872a3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an $AF = &lt;X,R&gt;$ and a set of arguments $S  X$. Decide whether S is a -extension of AF, i.e., S  E_(AF).  <a href="#ad038b5d309cbc354de30b0c9e872a3e0">More...</a><br /></td></tr>
<tr class="separator:ad038b5d309cbc354de30b0c9e872a3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36beb291f979465c4708f056974a8b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d18/classargumatrix_1_1_admissible_pl_reasoner.html#ab36beb291f979465c4708f056974a8b1">task_DN</a> ()</td></tr>
<tr class="memdesc:ab36beb291f979465c4708f056974a8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an $AF = &lt;X,R&gt;$ and a set of arguments $S  X$. Decide whether there exist a non-empty -extension for AF.  <a href="#ab36beb291f979465c4708f056974a8b1">More...</a><br /></td></tr>
<tr class="separator:ab36beb291f979465c4708f056974a8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b18e3fa677f2167e9d41b24e5cc0f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d18/classargumatrix_1_1_admissible_pl_reasoner.html#a99b18e3fa677f2167e9d41b24e5cc0f6">task_DC</a> (const std::set&lt; string &gt; &amp;argset)</td></tr>
<tr class="memdesc:a99b18e3fa677f2167e9d41b24e5cc0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an $AF = &lt;X,R&gt;$ and an argument s  X (respectively, a set of arguments $S  X$). Decide whether s contained (respectively, S included) in some E  E_(AF) (i.e., credulously justified).  <a href="#a99b18e3fa677f2167e9d41b24e5cc0f6">More...</a><br /></td></tr>
<tr class="separator:a99b18e3fa677f2167e9d41b24e5cc0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23484027cde4bbbfe2520eeda457b31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d18/classargumatrix_1_1_admissible_pl_reasoner.html#ac23484027cde4bbbfe2520eeda457b31">task_DS</a> (const std::set&lt; string &gt; &amp;argset)</td></tr>
<tr class="memdesc:ac23484027cde4bbbfe2520eeda457b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an $AF = &lt;X,R&gt;$ and an argument s  X (respectively, a set of arguments $S  X$). Decide whether s contained (respectively, S included) in each E  E_(AF) (i.e., skeptically justified).  <a href="#ac23484027cde4bbbfe2520eeda457b31">More...</a><br /></td></tr>
<tr class="separator:ac23484027cde4bbbfe2520eeda457b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7bfff1158322311019b2e351a6cebc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d9a/classargumatrix_1_1_pl_reasoner.html#aea7bfff1158322311019b2e351a6cebc">consultPlFile</a> (std::string plFile=ARG_PROLOG_FILE)</td></tr>
<tr class="memdesc:aea7bfff1158322311019b2e351a6cebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading the Prolog source file [argmat-clpb].  <a href="#aea7bfff1158322311019b2e351a6cebc">More...</a><br /></td></tr>
<tr class="separator:aea7bfff1158322311019b2e351a6cebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bdb42ed44b37ac976abd9cc06e25fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81bdb42ed44b37ac976abd9cc06e25fd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Test_time</b> ()</td></tr>
<tr class="separator:a81bdb42ed44b37ac976abd9cc06e25fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefce8d55a56c86ea536b846973490af8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d9a/classargumatrix_1_1_pl_reasoner.html#aefce8d55a56c86ea536b846973490af8">printAllExts</a> (const std::string &amp;predct)</td></tr>
<tr class="memdesc:aefce8d55a56c86ea536b846973490af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print all extensions with respect to semantic predct.  <a href="#aefce8d55a56c86ea536b846973490af8">More...</a><br /></td></tr>
<tr class="separator:aefce8d55a56c86ea536b846973490af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cfaf849c331ea50d51a2d3667cd298"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d9a/classargumatrix_1_1_pl_reasoner.html#a17cfaf849c331ea50d51a2d3667cd298">printAllExts</a> (const std::string &amp;predct, const std::set&lt; string &gt; &amp;argset)</td></tr>
<tr class="memdesc:a17cfaf849c331ea50d51a2d3667cd298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an ${AF}=&lt; {X}, {R}&gt;$ and an argument $s  {X}$ (respectively, a set of arguments $S {X}$), enumerate all sets $E {X}$ such that $E  {E}_(AF)$ and $s E$ (respectively, $S  E$).  <a href="#a17cfaf849c331ea50d51a2d3667cd298">More...</a><br /></td></tr>
<tr class="separator:a17cfaf849c331ea50d51a2d3667cd298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e1632b51e43911895bc5058be48845"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52e1632b51e43911895bc5058be48845"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printAllExts</b> (const std::string &amp;predct, const std::vector&lt; int &gt; &amp;vecii)</td></tr>
<tr class="separator:a52e1632b51e43911895bc5058be48845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c55acf89c4196e8edde52dffb6533f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c55acf89c4196e8edde52dffb6533f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printAllExts2</b> (const std::string &amp;predct)</td></tr>
<tr class="separator:a3c55acf89c4196e8edde52dffb6533f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2742c38ca590c69f81745eaeb95e51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d9a/classargumatrix_1_1_pl_reasoner.html#a1b2742c38ca590c69f81745eaeb95e51">fetchAllExts</a> (const std::string &amp;predct)</td></tr>
<tr class="separator:a1b2742c38ca590c69f81745eaeb95e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6fb6687d6e38b7600fac2e4c858db3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d9a/classargumatrix_1_1_pl_reasoner.html#abc6fb6687d6e38b7600fac2e4c858db3">printSomeExt</a> (const std::string &amp;predct, const std::set&lt; string &gt; &amp;argset)</td></tr>
<tr class="memdesc:abc6fb6687d6e38b7600fac2e4c858db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an ${AF}=&lt; {X}, {R}&gt;$ and an argument $s  {X}$ (respectively, a set of arguments $S {X}$), enumerate some set $E {X}$ such that $E  {E}_(AF)$ and $s E$ (respectively, $S  E$).  <a href="#abc6fb6687d6e38b7600fac2e4c858db3">More...</a><br /></td></tr>
<tr class="separator:abc6fb6687d6e38b7600fac2e4c858db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaca7ee7cae35e2124c997cf0930554b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeaca7ee7cae35e2124c997cf0930554b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printSomeExt</b> (const std::string &amp;predct, const vector&lt; int &gt; &amp;vecii)</td></tr>
<tr class="separator:aeaca7ee7cae35e2124c997cf0930554b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2365aa2d5ed04e7f85764e0386403a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d9a/classargumatrix_1_1_pl_reasoner.html#abb2365aa2d5ed04e7f85764e0386403a">verifyNonemptyExt</a> (const std::string &amp;predct)</td></tr>
<tr class="memdesc:abb2365aa2d5ed04e7f85764e0386403a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an $AF = &lt;X,R&gt;$ and a set of arguments $S  X$. Decide whether there exist a non-empty $$-extension for AF.  <a href="#abb2365aa2d5ed04e7f85764e0386403a">More...</a><br /></td></tr>
<tr class="separator:abb2365aa2d5ed04e7f85764e0386403a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ef282f52392a19388f769737a35bfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d9a/classargumatrix_1_1_pl_reasoner.html#a61ef282f52392a19388f769737a35bfa">verifyExtension</a> (const std::string &amp;predct, std::set&lt; string &gt; &amp;argset)</td></tr>
<tr class="memdesc:a61ef282f52392a19388f769737a35bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an $AF = &lt;X,R&gt;$ and a set of arguments $S  X$. Decide whether S is a $$-extension of AF, i.e., $S  E_(AF)$.  <a href="#a61ef282f52392a19388f769737a35bfa">More...</a><br /></td></tr>
<tr class="separator:a61ef282f52392a19388f769737a35bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac531cb249945a566a2fc19656fe906ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac531cb249945a566a2fc19656fe906ad"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>verifyExtension</b> (const std::string &amp;predct, <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;bvecii)</td></tr>
<tr class="separator:ac531cb249945a566a2fc19656fe906ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d1ae4221c084da61e4167f405dbaf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d9a/classargumatrix_1_1_pl_reasoner.html#a54d1ae4221c084da61e4167f405dbaf2">isCredulouslyJustified</a> (const std::string &amp;predct, const std::set&lt; string &gt; &amp;argset)</td></tr>
<tr class="memdesc:a54d1ae4221c084da61e4167f405dbaf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an $AF = &lt;X,R&gt;$ and an argument s  X (respectively, a set of arguments $S  X$). Decide whether s contained (respectively, S included) in some E  E_(AF) (i.e., credulously justified).  <a href="#a54d1ae4221c084da61e4167f405dbaf2">More...</a><br /></td></tr>
<tr class="separator:a54d1ae4221c084da61e4167f405dbaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a234b20a9122838d85841fc069c925"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d9a/classargumatrix_1_1_pl_reasoner.html#a69a234b20a9122838d85841fc069c925">isSkepticallyJustified</a> (const std::string &amp;predct, const std::set&lt; string &gt; &amp;argset)</td></tr>
<tr class="memdesc:a69a234b20a9122838d85841fc069c925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an $AF = &lt;X,R&gt;$ and an argument s  X (respectively, a set of arguments $S  X$). Decide whether s contained (respectively, S included) in each E  E_(AF) (i.e., skeptically justified).  <a href="#a69a234b20a9122838d85841fc069c925">More...</a><br /></td></tr>
<tr class="separator:a69a234b20a9122838d85841fc069c925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8358d63da6d7bc793d923adbd0b75c8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a8358d63da6d7bc793d923adbd0b75c8f">getAttacked</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;_bv)</td></tr>
<tr class="memdesc:a8358d63da6d7bc793d923adbd0b75c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the attacked arguments by arguments in _bv, \(R^+(S)\) \(R^+(S) = {x|x is attacked by S}\). \(R^+(S_bv) = D*S_bv\).  <a href="#a8358d63da6d7bc793d923adbd0b75c8f">More...</a><br /></td></tr>
<tr class="separator:a8358d63da6d7bc793d923adbd0b75c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee95de8e7d8bdbe361c3a591fe9830e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a3ee95de8e7d8bdbe361c3a591fe9830e">characteristic</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;_bv)</td></tr>
<tr class="memdesc:a3ee95de8e7d8bdbe361c3a591fe9830e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The characteristic function of an abstract argumentation framework: \(F_{AF}(S) = {A|A is acceptable wrt. S}\). F_AF(S_bv) = not{ R^+[ not( R^+(S_bv) ) ] }.  <a href="#a3ee95de8e7d8bdbe361c3a591fe9830e">More...</a><br /></td></tr>
<tr class="separator:a3ee95de8e7d8bdbe361c3a591fe9830e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2771798ec784cd9391baf4390a9a94e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#af2771798ec784cd9391baf4390a9a94e">characteristic</a> ()</td></tr>
<tr class="memdesc:af2771798ec784cd9391baf4390a9a94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The characteristic function of an abstract argumentation framework with the initialization of empty set.  <a href="#af2771798ec784cd9391baf4390a9a94e">More...</a><br /></td></tr>
<tr class="separator:af2771798ec784cd9391baf4390a9a94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1a72e344c8fd2f2d907840549fcebf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#ace1a72e344c8fd2f2d907840549fcebf">neutrality</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;_bv)</td></tr>
<tr class="memdesc:ace1a72e344c8fd2f2d907840549fcebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The neutrality function of an abstract argumentation framework: N_AF(S) = {A| All arguments that not attacked by S}. N_AF(S_bv) = not( R^+(S_bv) )  <a href="#ace1a72e344c8fd2f2d907840549fcebf">More...</a><br /></td></tr>
<tr class="separator:ace1a72e344c8fd2f2d907840549fcebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adcecab0610f6417418c56a3980dfe6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a3adcecab0610f6417418c56a3980dfe6">is_conflict_free</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;_bv)</td></tr>
<tr class="memdesc:a3adcecab0610f6417418c56a3980dfe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument set S is conflict-free? S is said to be conflict-free iff for any two arguments a,b in S such that a does not attack b.  <a href="#a3adcecab0610f6417418c56a3980dfe6">More...</a><br /></td></tr>
<tr class="separator:a3adcecab0610f6417418c56a3980dfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a71a5e6ed451127a85fc80f91f1ca8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a71a5e6ed451127a85fc80f91f1ca8d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_conflict_free</b> (const set&lt; string &gt; &amp;argset)</td></tr>
<tr class="separator:a3a71a5e6ed451127a85fc80f91f1ca8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5b58f532ab6ebe97dd9df5bfaec750"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a6a5b58f532ab6ebe97dd9df5bfaec750">is_acceptable</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;S, const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;A)</td></tr>
<tr class="memdesc:a6a5b58f532ab6ebe97dd9df5bfaec750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument set A is acceptable w.r.t S? Alternately, S defends A? A can be an argument or an argument set. S defends argument (set) A iff for any argument x in X, if attacks A (or a in A) then there is an argument y in S such that y attacks x.  <a href="#a6a5b58f532ab6ebe97dd9df5bfaec750">More...</a><br /></td></tr>
<tr class="separator:a6a5b58f532ab6ebe97dd9df5bfaec750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847a5aee187ac032f73a671c9af92833"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a847a5aee187ac032f73a671c9af92833">is_self_attacking</a> (size_type idx)</td></tr>
<tr class="memdesc:a847a5aee187ac032f73a671c9af92833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument a is self-attacking iff it attacks itself.  <a href="#a847a5aee187ac032f73a671c9af92833">More...</a><br /></td></tr>
<tr class="separator:a847a5aee187ac032f73a671c9af92833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9ff217d7ac88b3ae98ff9709e5be0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#aed9ff217d7ac88b3ae98ff9709e5be0e">is_admissible</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;_bv)</td></tr>
<tr class="memdesc:aed9ff217d7ac88b3ae98ff9709e5be0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">To decide whether a set of arguments (with the form of bitvector) is an admissible extension. $S$ is an admissible extension iff $S  F(S)  N(S)$.  <a href="#aed9ff217d7ac88b3ae98ff9709e5be0e">More...</a><br /></td></tr>
<tr class="separator:aed9ff217d7ac88b3ae98ff9709e5be0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e190e21d8e00a26590cb4850764273"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a99e190e21d8e00a26590cb4850764273">is_complete</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;_bv)</td></tr>
<tr class="memdesc:a99e190e21d8e00a26590cb4850764273"><td class="mdescLeft">&#160;</td><td class="mdescRight">To decide whether a set of arguments (with the form of bitvector) is a complete extension. $S$ is a complete extension iff $S == F(S)  N(S)$.  <a href="#a99e190e21d8e00a26590cb4850764273">More...</a><br /></td></tr>
<tr class="separator:a99e190e21d8e00a26590cb4850764273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf96b178007b837d780237aea4beb1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#aadf96b178007b837d780237aea4beb1b">is_stable</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;_bv)</td></tr>
<tr class="memdesc:aadf96b178007b837d780237aea4beb1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">To decide whether a set of arguments (with the form of bitvector) is a stable extension. $S$ is a stable extension iff $S == N(S)$.  <a href="#aadf96b178007b837d780237aea4beb1b">More...</a><br /></td></tr>
<tr class="separator:aadf96b178007b837d780237aea4beb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31b6af53cfed1a4b3652dc509763fce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#af31b6af53cfed1a4b3652dc509763fce">is_grounded</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;_bv)</td></tr>
<tr class="memdesc:af31b6af53cfed1a4b3652dc509763fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">To decide whether a set of arguments (with the form of bitvector) is a grounded extension. $S$ is a grounded extension iff it is the least fixed point of the characteristic function F.  <a href="#af31b6af53cfed1a4b3652dc509763fce">More...</a><br /></td></tr>
<tr class="separator:af31b6af53cfed1a4b3652dc509763fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae733bcb7ab64468c08c0d0189ba6a6dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#ae733bcb7ab64468c08c0d0189ba6a6dc">getSelfAttackingArguments</a> ()</td></tr>
<tr class="memdesc:ae733bcb7ab64468c08c0d0189ba6a6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all arguments which are self-attacking. Obviously, if an argument i attacks itself, the entry[i][i] of the attack matrix must be 1 (true). Therefore to get the set of self-attacking arguments is to get the diagonal elements of the attack matrix.  <a href="#ae733bcb7ab64468c08c0d0189ba6a6dc">More...</a><br /></td></tr>
<tr class="separator:ae733bcb7ab64468c08c0d0189ba6a6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01963934038ed4cf5d407e228d38f774"><td class="memItemLeft" align="right" valign="top">const set&lt; <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a01963934038ed4cf5d407e228d38f774">getBvExtensions</a> ()</td></tr>
<tr class="memdesc:a01963934038ed4cf5d407e228d38f774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all extensions given a specific semantics in format of bitvector. Each extension is a set of arguments which can "survive the conflict
together". Here, we use a bitvector to represent an extension. Therefore, all extensions are formed an set of bit vectors, i.e., set&lt;bitvector&gt;. Each bitvector in set is an extension w.r.t. a given semantics. The computed extensions are stored in m_extensions, therefore, to get all extensions, it must first invoke the function computeExtension()  <a href="#a01963934038ed4cf5d407e228d38f774">More...</a><br /></td></tr>
<tr class="separator:a01963934038ed4cf5d407e228d38f774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e70726a3d9ec8021e18cfe46191f63"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a21e70726a3d9ec8021e18cfe46191f63">getGroundedIntVector</a> ()</td></tr>
<tr class="memdesc:a21e70726a3d9ec8021e18cfe46191f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector of integers {0, 1, 2}: 2 &ndash; Unknown, 1 &ndash; in grounded extension, and 0 &ndash; attacked by the grounded extension.  <a href="#a21e70726a3d9ec8021e18cfe46191f63">More...</a><br /></td></tr>
<tr class="separator:a21e70726a3d9ec8021e18cfe46191f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d09964e79bb4778820e996554acbb65"><td class="memItemLeft" align="right" valign="top">streambuf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a2d09964e79bb4778820e996554acbb65">setOutput</a> (streambuf *strbuf)</td></tr>
<tr class="memdesc:a2d09964e79bb4778820e996554acbb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirect the output stream to streambuf* strbuf or ostream&amp; os. If strbuf = cout.rdbuf(), then the output is standard output. It can also redirect the output to a file by the following codes: </p><div class="fragment"><div class="line">ofstream ofile(<span class="stringliteral">&quot;output.txt&quot;</span>);</div><div class="line">streambuf* oldsb = xxx.setOutput(ofile.rdbuf()); </div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line">streambuf* oldsb = xxx.setOutput(ofile); </div></div><!-- fragment --><p>.  <a href="#a2d09964e79bb4778820e996554acbb65">More...</a><br /></td></tr>
<tr class="separator:a2d09964e79bb4778820e996554acbb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3783f1330a7fba62afd0b2953c3855"><td class="memItemLeft" align="right" valign="top">streambuf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#acf3783f1330a7fba62afd0b2953c3855">setOutput</a> (ostream &amp;os=std::cout)</td></tr>
<tr class="separator:acf3783f1330a7fba62afd0b2953c3855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f980ea40699bad16a08645b71f1b5de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a9f980ea40699bad16a08645b71f1b5de">printLabSet</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;bv_ext)</td></tr>
<tr class="memdesc:a9f980ea40699bad16a08645b71f1b5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an extension with the form of bitvector. Assume the bitvector is [0, 1, 0, 1], the arguments corresponding to entry 1 will be print. The member <em>m_output</em> will determine where to print.  <a href="#a9f980ea40699bad16a08645b71f1b5de">More...</a><br /></td></tr>
<tr class="separator:a9f980ea40699bad16a08645b71f1b5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d13479a03bf2e760a227e7a47b7d54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#aa7d13479a03bf2e760a227e7a47b7d54">printLabSet</a> (const std::set&lt; string &gt; &amp;labset)</td></tr>
<tr class="memdesc:aa7d13479a03bf2e760a227e7a47b7d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a set of arguments. The member <em>m_output</em> will determine where to print.  <a href="#aa7d13479a03bf2e760a227e7a47b7d54">More...</a><br /></td></tr>
<tr class="separator:aa7d13479a03bf2e760a227e7a47b7d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9d4c09c36aaa5f6489e4a904592cc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a9a9d4c09c36aaa5f6489e4a904592cc0">printBvExts</a> ()</td></tr>
<tr class="memdesc:a9a9d4c09c36aaa5f6489e4a904592cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output all extensions given a specific semantics with an ostream. Each extension is a set of arguments which can "survive the conflict
together". Here, we return a string to represent all extensions. For example, if there are two extensions, [a,b] and [b, d], for some problem w.r.t. a given semantics, then we return string "[[a,b],[d,c]]". If extensions is not existing, the string "[]" will return.  <a href="#a9a9d4c09c36aaa5f6489e4a904592cc0">More...</a><br /></td></tr>
<tr class="separator:a9a9d4c09c36aaa5f6489e4a904592cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9586dcec7cbe8ec4d36da47fe34f21d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a9586dcec7cbe8ec4d36da47fe34f21d6">getGroundedExtension</a> ()</td></tr>
<tr class="memdesc:a9586dcec7cbe8ec4d36da47fe34f21d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the grounded extension.  <a href="#a9586dcec7cbe8ec4d36da47fe34f21d6">More...</a><br /></td></tr>
<tr class="separator:a9586dcec7cbe8ec4d36da47fe34f21d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167ee1f6201541666757fc610d9dd050"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a167ee1f6201541666757fc610d9dd050">printGroundedExt</a> ()</td></tr>
<tr class="memdesc:a167ee1f6201541666757fc610d9dd050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the grounded extension.  <a href="#a167ee1f6201541666757fc610d9dd050">More...</a><br /></td></tr>
<tr class="separator:a167ee1f6201541666757fc610d9dd050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ad3b22ab7f508695863be0279fb7cd"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#ac5ad3b22ab7f508695863be0279fb7cd">labelSet2IntVector</a> (const std::set&lt; string &gt; &amp;label_set)</td></tr>
<tr class="memdesc:ac5ad3b22ab7f508695863be0279fb7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a set of argument (string) labels to an integer vector of {0,1,2}, All arguments in these set, the indices is 1; otherwise 2 (representing unknown)  <a href="#ac5ad3b22ab7f508695863be0279fb7cd">More...</a><br /></td></tr>
<tr class="separator:ac5ad3b22ab7f508695863be0279fb7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aad308e0310e6733231b9134fb8362e9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d9a/classargumatrix_1_1_pl_reasoner.html#aad308e0310e6733231b9134fb8362e9c">findAllExts</a> (const std::string &amp;predct)</td></tr>
<tr class="memdesc:aad308e0310e6733231b9134fb8362e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all extensions and store them in <em>m_extensions</em> with the form of bitvector.  <a href="#aad308e0310e6733231b9134fb8362e9c">More...</a><br /></td></tr>
<tr class="separator:aad308e0310e6733231b9134fb8362e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7f1a4eeaa85c71bbd339bab52d20c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d9a/classargumatrix_1_1_pl_reasoner.html#abe7f1a4eeaa85c71bbd339bab52d20c4">createPlAttackMatrix</a> ()</td></tr>
<tr class="memdesc:abe7f1a4eeaa85c71bbd339bab52d20c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the attack matrix with the form of PlTerm, which is an input of SWI-Prolog.  <a href="#abe7f1a4eeaa85c71bbd339bab52d20c4">More...</a><br /></td></tr>
<tr class="separator:abe7f1a4eeaa85c71bbd339bab52d20c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e5f24db0150d3b5ffe21b8f976c129"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d9a/classargumatrix_1_1_pl_reasoner.html#af6e5f24db0150d3b5ffe21b8f976c129">printLableExtByBlistTerm</a> (const PlTerm &amp;plt)</td></tr>
<tr class="memdesc:af6e5f24db0150d3b5ffe21b8f976c129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an extension with the form of the bool list term. Assume a bool list term is [0, 1, 0, 1], the arguments corresponding to entry 1 will be print. The member <em>m_output</em> will determine where to print.  <a href="#af6e5f24db0150d3b5ffe21b8f976c129">More...</a><br /></td></tr>
<tr class="separator:af6e5f24db0150d3b5ffe21b8f976c129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5afa25f1fc31cefef9a1c6a47c3846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d9a/classargumatrix_1_1_pl_reasoner.html#a0d5afa25f1fc31cefef9a1c6a47c3846">printLableExtByBmatrixTerm</a> (const PlTerm &amp;pmtx)</td></tr>
<tr class="memdesc:a0d5afa25f1fc31cefef9a1c6a47c3846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an extension with the form of the bool matrix term. Assume a bool list term is [[0, 1, 0, 1], [0, 1, 0, 1]], the arguments corresponding to entry 1 will be print. The member <em>m_output</em> will determine where to print.  <a href="#a0d5afa25f1fc31cefef9a1c6a47c3846">More...</a><br /></td></tr>
<tr class="separator:a0d5afa25f1fc31cefef9a1c6a47c3846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c538b9cb16d5651c5b73720f25b91f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d9a/classargumatrix_1_1_pl_reasoner.html#a90c538b9cb16d5651c5b73720f25b91f">addBlTermToBvExts</a> (const PlTerm &amp;plt)</td></tr>
<tr class="memdesc:a90c538b9cb16d5651c5b73720f25b91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a bool list term into a bitvertor, and add it to extension.  <a href="#a90c538b9cb16d5651c5b73720f25b91f">More...</a><br /></td></tr>
<tr class="separator:a90c538b9cb16d5651c5b73720f25b91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed707a454fc88e71c9c546685f4eed94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d9a/classargumatrix_1_1_pl_reasoner.html#aed707a454fc88e71c9c546685f4eed94">verifyInclusion</a> (const std::string &amp;predct, const vector&lt; int &gt; &amp;vecii)</td></tr>
<tr class="memdesc:aed707a454fc88e71c9c546685f4eed94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an $AF = &lt;X,R&gt;$ and a set of arguments $S  X$. Decide whether there exist a -extension that includes S.  <a href="#aed707a454fc88e71c9c546685f4eed94">More...</a><br /></td></tr>
<tr class="separator:aed707a454fc88e71c9c546685f4eed94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f0118ec8c837fa154b5a9fa16a24dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d9a/classargumatrix_1_1_pl_reasoner.html#a11f0118ec8c837fa154b5a9fa16a24dc">verifyExclusion</a> (const std::string &amp;predct, const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;vecB)</td></tr>
<tr class="memdesc:a11f0118ec8c837fa154b5a9fa16a24dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an $AF = &lt;X,R&gt;$ and a set of arguments $S  X$. Decide whether there exist a -extension that excludes S.  <a href="#a11f0118ec8c837fa154b5a9fa16a24dc">More...</a><br /></td></tr>
<tr class="separator:a11f0118ec8c837fa154b5a9fa16a24dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:afcfec6f455c28d90e7f4b1dc64c67194"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcfec6f455c28d90e7f4b1dc64c67194"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>m_predicate</b></td></tr>
<tr class="separator:afcfec6f455c28d90e7f4b1dc64c67194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60cfd4bc6def01e4949d0959e5d6ef73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60cfd4bc6def01e4949d0959e5d6ef73"></a>
PlTerm&#160;</td><td class="memItemRight" valign="bottom"><b>m_PlAtkMtx</b></td></tr>
<tr class="separator:a60cfd4bc6def01e4949d0959e5d6ef73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4daaa89514c4e3335661cdf8652e64ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d64/classargumatrix_1_1bitmatrix.html">bitmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a4daaa89514c4e3335661cdf8652e64ad">m_BmAtkMtx</a></td></tr>
<tr class="separator:a4daaa89514c4e3335661cdf8652e64ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8d4a980b742479272808e2870dc957"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#aef8d4a980b742479272808e2870dc957">m_argNum</a></td></tr>
<tr class="separator:aef8d4a980b742479272808e2870dc957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f4fddc89b83dfb5179c4028658c613"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d1/d62/classargumatrix_1_1_dung_a_f.html">DungAF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a11f4fddc89b83dfb5179c4028658c613">m_daf</a></td></tr>
<tr class="separator:a11f4fddc89b83dfb5179c4028658c613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b64952543efd9e20765015fed63d23b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b64952543efd9e20765015fed63d23b"></a>
set&lt; <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_extensions</b></td></tr>
<tr class="separator:a1b64952543efd9e20765015fed63d23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6776638576fce3158fef6b6d970b3d5"><td class="memItemLeft" align="right" valign="top">vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#ad6776638576fce3158fef6b6d970b3d5">m_argLabels</a></td></tr>
<tr class="separator:ad6776638576fce3158fef6b6d970b3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dda7c4ca8b4391d929b7f4ce14f1db1"><td class="memItemLeft" align="right" valign="top">std::ostream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a0dda7c4ca8b4391d929b7f4ce14f1db1">m_output</a></td></tr>
<tr class="separator:a0dda7c4ca8b4391d929b7f4ce14f1db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html#l00037">37</a> of file <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html">AdmissiblePlReasoner.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a90c538b9cb16d5651c5b73720f25b91f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void argumatrix::PlReasoner::addBlTermToBvExts </td>
          <td>(</td>
          <td class="paramtype">const PlTerm &amp;&#160;</td>
          <td class="paramname"><em>plt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a bool list term into a bitvertor, and add it to extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PlTerm&amp;</td><td>plt : The PlTerm is a bool list term, which represents an extension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. The results are added into m_extensions. </dd></dl>

<p>Definition at line <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html#l00303">303</a> of file <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html">PlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ee95de8e7d8bdbe361c3a591fe9830e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">argumatrix::bitvector</a> argumatrix::Reasoner::characteristic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>_bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The characteristic function of an abstract argumentation framework: \(F_{AF}(S) = {A|A is acceptable wrt. S}\). F_AF(S_bv) = not{ R^+[ not( R^+(S_bv) ) ] }. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extension</td><td>an extension (a set of arguments), the default is empty set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a set of arguments in bitvector form. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00368">368</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2771798ec784cd9391baf4390a9a94e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">argumatrix::bitvector</a> argumatrix::Reasoner::characteristic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The characteristic function of an abstract argumentation framework with the initialization of empty set. </p>
<dl class="section return"><dt>Returns</dt><dd>a set of arguments in bitvector form. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00375">375</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00484">argumatrix::Reasoner::getGroundedExtension()</a>, and <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00394">argumatrix::Reasoner::is_acceptable()</a>.</p>

</div>
</div>
<a class="anchor" id="aea7bfff1158322311019b2e351a6cebc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void argumatrix::PlReasoner::consultPlFile </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>plFile</em> = <code>ARG_PROLOG_FILE</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading the Prolog source file [argmat-clpb]. </p>
<p>Method: consultPlFile </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::string</td><td>plFile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>SWI-Prolog supports compilation of individual or multiple Prolog source files into ‘Quick Load Files’. A ‘Quick Load File’ (.qlf file) stores the contents of the file in a precompiled format. These files load considerably faster than source files and are normally more compact. They are machine-independent and may thus be loaded on any implementation of SWI-Prolog. Note, however, that clauses are stored as virtual machine instructions. Changes to the compiler will generally make old compiled files unusable. Quick Load Files are created using qcompile/1. They are loaded using consult/1 or one of the other file-loading predicates described in section 4.3. If consult/1 is given an explicit .pl file, it will load the Prolog source. When given a .qlf file, it will load the file. When no extension is specified, it will load the .qlf file when present and the .pl file otherwise. </dd></dl>

<p>Definition at line <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html#l00253">253</a> of file <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html">PlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abe7f1a4eeaa85c71bbd339bab52d20c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void argumatrix::PlReasoner::createPlAttackMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the attack matrix with the form of PlTerm, which is an input of SWI-Prolog. </p>
<dl class="section return"><dt>Returns</dt><dd>no return. The result is stored in member variable <em>m_PlAtkMtx</em>. </dd></dl>

<p>Definition at line <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html#l00243">243</a> of file <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html">PlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1b2742c38ca590c69f81745eaeb95e51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void argumatrix::PlReasoner::fetchAllExts </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>predct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method: fetchAllExts FullName: public <a class="el" href="../../dd/d9a/classargumatrix_1_1_pl_reasoner.html#a1b2742c38ca590c69f81745eaeb95e51">argumatrix::PlReasoner::fetchAllExts</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>std::string &amp; predct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html#l00701">701</a> of file <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html">PlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab6ee5219f0f3d62919e785fc358f86f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__inline void argumatrix::AdmissiblePlReasoner::findAllExts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find all extensions and store them in <em>m_extensions</em> with the form of bitvector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">no</td><td>argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. The results are added into <em>m_extensions</em>. </dd></dl>

<p>Definition at line <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html#l00177">177</a> of file <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html">AdmissiblePlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad308e0310e6733231b9134fb8362e9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void argumatrix::PlReasoner::findAllExts </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>predct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all extensions and store them in <em>m_extensions</em> with the form of bitvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string&amp;</td><td>predct: The predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. The results are added into <em>m_extensions</em>. </dd></dl>

<p>Definition at line <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html#l00669">669</a> of file <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html">PlReasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html#l00177">findAllExts()</a>, <a class="el" href="../../d6/d26/_stable_pl_reasoner_8hpp_source.html#l00169">argumatrix::StablePlReasoner::findAllExts()</a>, <a class="el" href="../../de/d88/_conflictfree_pl_reasoner_8hpp_source.html#l00176">argumatrix::ConflictfreePlReasoner::findAllExts()</a>, and <a class="el" href="../../d1/dff/_complete_pl_reasoner_8hpp_source.html#l00193">argumatrix::CompletePlReasoner::findAllExts()</a>.</p>

</div>
</div>
<a class="anchor" id="a8358d63da6d7bc793d923adbd0b75c8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">argumatrix::bitvector</a> argumatrix::Reasoner::getAttacked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>_bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the attacked arguments by arguments in _bv, \(R^+(S)\) \(R^+(S) = {x|x is attacked by S}\). \(R^+(S_bv) = D*S_bv\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_bv</td><td>the bitvector with respect to the set \(S\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a set of arguments in bitvector form. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00360">360</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00499">argumatrix::Reasoner::getGroundedIntVector()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00381">argumatrix::Reasoner::is_conflict_free()</a>, and <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00547">argumatrix::Reasoner::neutrality()</a>.</p>

</div>
</div>
<a class="anchor" id="a01963934038ed4cf5d407e228d38f774"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline const set&lt; <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &gt; &amp; argumatrix::Reasoner::getBvExtensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all extensions given a specific semantics in format of bitvector. Each extension is a set of arguments which can "survive the conflict
together". Here, we use a bitvector to represent an extension. Therefore, all extensions are formed an set of bit vectors, i.e., set&lt;bitvector&gt;. Each bitvector in set is an extension w.r.t. a given semantics. The computed extensions are stored in m_extensions, therefore, to get all extensions, it must first invoke the function computeExtension() </p>
<dl class="section return"><dt>Returns</dt><dd>a set of bitvector, i.e., set&lt;bitvector&gt;. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00400">400</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9586dcec7cbe8ec4d36da47fe34f21d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">argumatrix::bitvector</a> argumatrix::Reasoner::getGroundedExtension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the grounded extension. </p>
<dl class="section return"><dt>Returns</dt><dd>a set of arguments in bitvector form. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00484">484</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00584">argumatrix::Reasoner::is_grounded()</a>, and <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00539">argumatrix::Reasoner::printGroundedExt()</a>.</p>

</div>
</div>
<a class="anchor" id="a21e70726a3d9ec8021e18cfe46191f63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; argumatrix::Reasoner::getGroundedIntVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a vector of integers {0, 1, 2}: 2 &ndash; Unknown, 1 &ndash; in grounded extension, and 0 &ndash; attacked by the grounded extension. </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of integers {0, 1, 2}. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00499">499</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae733bcb7ab64468c08c0d0189ba6a6dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">argumatrix::bitvector</a> argumatrix::Reasoner::getSelfAttackingArguments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all arguments which are self-attacking. Obviously, if an argument i attacks itself, the entry[i][i] of the attack matrix must be 1 (true). Therefore to get the set of self-attacking arguments is to get the diagonal elements of the attack matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>a set of arguments in bitvector form, if bitvector[i] = true representing the argument (with index) i is a self-attacking argument, otherwise is not. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00414">414</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6a5b58f532ab6ebe97dd9df5bfaec750"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline bool argumatrix::Reasoner::is_acceptable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Argument set A is acceptable w.r.t S? Alternately, S defends A? A can be an argument or an argument set. S defends argument (set) A iff for any argument x in X, if attacks A (or a in A) then there is an argument y in S such that y attacks x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>a set of arguments. </td></tr>
    <tr><td class="paramname">A</td><td>an argument or an argument set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if S defends A. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00394">394</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed9ff217d7ac88b3ae98ff9709e5be0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline bool argumatrix::Reasoner::is_admissible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>_bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To decide whether a set of arguments (with the form of bitvector) is an admissible extension. $S$ is an admissible extension iff $S  F(S)  N(S)$. </p>
<dl class="section return"><dt>Returns</dt><dd>true if _bv is admissible; otherwise returns false. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00553">553</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a99e190e21d8e00a26590cb4850764273"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline bool argumatrix::Reasoner::is_complete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>_bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To decide whether a set of arguments (with the form of bitvector) is a complete extension. $S$ is a complete extension iff $S == F(S)  N(S)$. </p>
<dl class="section return"><dt>Returns</dt><dd>true if _bv is complete; otherwise returns false. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00564">564</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3adcecab0610f6417418c56a3980dfe6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline bool argumatrix::Reasoner::is_conflict_free </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>_bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Argument set S is conflict-free? S is said to be conflict-free iff for any two arguments a,b in S such that a does not attack b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extension</td><td>an extension (a set of arguments). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if S is conflict-free. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00381">381</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af31b6af53cfed1a4b3652dc509763fce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline bool argumatrix::Reasoner::is_grounded </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>_bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To decide whether a set of arguments (with the form of bitvector) is a grounded extension. $S$ is a grounded extension iff it is the least fixed point of the characteristic function F. </p>
<dl class="section return"><dt>Returns</dt><dd>true if _bv is grounded; otherwise returns false. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00584">584</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a847a5aee187ac032f73a671c9af92833"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline bool argumatrix::Reasoner::is_self_attacking </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Argument a is self-attacking iff it attacks itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the index of the argument w.r.t the attack matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if S defends A. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00406">406</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aadf96b178007b837d780237aea4beb1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline bool argumatrix::Reasoner::is_stable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>_bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To decide whether a set of arguments (with the form of bitvector) is a stable extension. $S$ is a stable extension iff $S == N(S)$. </p>
<dl class="section return"><dt>Returns</dt><dd>true if _bv is stable; otherwise returns false. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00575">575</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a54d1ae4221c084da61e4167f405dbaf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool argumatrix::PlReasoner::isCredulouslyJustified </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>predct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>argset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an $AF = &lt;X,R&gt;$ and an argument s  X (respectively, a set of arguments $S  X$). Decide whether s contained (respectively, S included) in some E  E_(AF) (i.e., credulously justified). </p>
<p>Problem [DC-$$] </p>

<p>Definition at line <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html#l00642">642</a> of file <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html">PlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69a234b20a9122838d85841fc069c925"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool argumatrix::PlReasoner::isSkepticallyJustified </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>predct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>argset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an $AF = &lt;X,R&gt;$ and an argument s  X (respectively, a set of arguments $S  X$). Decide whether s contained (respectively, S included) in each E  E_(AF) (i.e., skeptically justified). </p>
<p>Problem [DS-$$] </p>

<p>Definition at line <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html#l00654">654</a> of file <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html">PlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5ad3b22ab7f508695863be0279fb7cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; argumatrix::Reasoner::labelSet2IntVector </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>label_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a set of argument (string) labels to an integer vector of {0,1,2}, All arguments in these set, the indices is 1; otherwise 2 (representing unknown) </p>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00526">526</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace1a72e344c8fd2f2d907840549fcebf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">argumatrix::bitvector</a> argumatrix::Reasoner::neutrality </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>_bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The neutrality function of an abstract argumentation framework: N_AF(S) = {A| All arguments that not attacked by S}. N_AF(S_bv) = not( R^+(S_bv) ) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extension</td><td>an extension (a set of arguments). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a set of arguments in bitvector form. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00547">547</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00368">argumatrix::Reasoner::characteristic()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00499">argumatrix::Reasoner::getGroundedIntVector()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00553">argumatrix::Reasoner::is_admissible()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00564">argumatrix::Reasoner::is_complete()</a>, and <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00575">argumatrix::Reasoner::is_stable()</a>.</p>

</div>
</div>
<a class="anchor" id="aefce8d55a56c86ea536b846973490af8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void argumatrix::PlReasoner::printAllExts </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>predct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print all extensions with respect to semantic predct. </p>
<p>Problem [EE-$$] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">no</td><td>argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>

<p>Definition at line <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html#l00430">430</a> of file <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html">PlReasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html#l00386">argumatrix::PlReasoner::printAllExts()</a>, <a class="el" href="../../d6/d26/_stable_pl_reasoner_8hpp_source.html#l00158">argumatrix::StablePlReasoner::task_EC()</a>, <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html#l00166">task_EC()</a>, <a class="el" href="../../de/d88/_conflictfree_pl_reasoner_8hpp_source.html#l00165">argumatrix::ConflictfreePlReasoner::task_EC()</a>, <a class="el" href="../../d1/dff/_complete_pl_reasoner_8hpp_source.html#l00182">argumatrix::CompletePlReasoner::task_EC()</a>, <a class="el" href="../../de/d88/_conflictfree_pl_reasoner_8hpp_source.html#l00157">argumatrix::ConflictfreePlReasoner::task_EE()</a>, <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html#l00160">task_EE()</a>, <a class="el" href="../../d6/d26/_stable_pl_reasoner_8hpp_source.html#l00151">argumatrix::StablePlReasoner::task_EE()</a>, and <a class="el" href="../../d1/dff/_complete_pl_reasoner_8hpp_source.html#l00175">argumatrix::CompletePlReasoner::task_EE()</a>.</p>

</div>
</div>
<a class="anchor" id="a17cfaf849c331ea50d51a2d3667cd298"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline void argumatrix::PlReasoner::printAllExts </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>predct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>argset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an ${AF}=&lt; {X}, {R}&gt;$ and an argument $s  {X}$ (respectively, a set of arguments $S {X}$), enumerate all sets $E {X}$ such that $E  {E}_(AF)$ and $s E$ (respectively, $S  E$). </p>
<p>Problem [EC-$$] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set&lt;string&gt;,or</td><td>a Boolean vector: a set of argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>

<p>Definition at line <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html#l00386">386</a> of file <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html">PlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9a9d4c09c36aaa5f6489e4a904592cc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline void argumatrix::Reasoner::printBvExts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output all extensions given a specific semantics with an ostream. Each extension is a set of arguments which can "survive the conflict
together". Here, we return a string to represent all extensions. For example, if there are two extensions, [a,b] and [b, d], for some problem w.r.t. a given semantics, then we return string "[[a,b],[d,c]]". If extensions is not existing, the string "[]" will return. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostream&amp;</td><td>os = std::cout, output the resluts into the ostream os. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a set of bitvector, i.e., set&lt;bitvector&gt;. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00428">428</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a167ee1f6201541666757fc610d9dd050"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline void argumatrix::Reasoner::printGroundedExt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the grounded extension. </p>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00539">539</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6e5f24db0150d3b5ffe21b8f976c129"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void argumatrix::PlReasoner::printLableExtByBlistTerm </td>
          <td>(</td>
          <td class="paramtype">const PlTerm &amp;&#160;</td>
          <td class="paramname"><em>plt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an extension with the form of the bool list term. Assume a bool list term is [0, 1, 0, 1], the arguments corresponding to entry 1 will be print. The member <em>m_output</em> will determine where to print. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PlTerm&amp;</td><td>plt : The PlTerm is a bool list term, which represents an extension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>

<p>Definition at line <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html#l00271">271</a> of file <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html">PlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0d5afa25f1fc31cefef9a1c6a47c3846"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void argumatrix::PlReasoner::printLableExtByBmatrixTerm </td>
          <td>(</td>
          <td class="paramtype">const PlTerm &amp;&#160;</td>
          <td class="paramname"><em>pmtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an extension with the form of the bool matrix term. Assume a bool list term is [[0, 1, 0, 1], [0, 1, 0, 1]], the arguments corresponding to entry 1 will be print. The member <em>m_output</em> will determine where to print. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PlTerm&amp;</td><td>plt : The PlTerm is a bool list term, which represents an extension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>

<p>Definition at line <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html#l00725">725</a> of file <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html">PlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f980ea40699bad16a08645b71f1b5de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void argumatrix::Reasoner::printLabSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_ext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an extension with the form of bitvector. Assume the bitvector is [0, 1, 0, 1], the arguments corresponding to entry 1 will be print. The member <em>m_output</em> will determine where to print. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitvector&amp;</td><td>bv_ext : The bv_ext is a bitvector, which represents an extension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>[<a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a2d09964e79bb4778820e996554acbb65" title="Redirect the output stream to streambuf* strbuf or ostream&amp; os. If strbuf = cout.rdbuf(), then the output is standard output. It can also redirect the output to a file by the following codes: ofstream ofile(&quot;output.txt&quot;); streambuf* oldsb = xxx.setOutput(ofile.rdbuf());  or streambuf* oldsb = xxx.setOutput(ofile); . ">setOutput</a>] </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00433">433</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00539">argumatrix::Reasoner::printGroundedExt()</a>.</p>

</div>
</div>
<a class="anchor" id="aa7d13479a03bf2e760a227e7a47b7d54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void argumatrix::Reasoner::printLabSet </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>labset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a set of arguments. The member <em>m_output</em> will determine where to print. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>std::set&lt;string&gt;&amp; labset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a2d09964e79bb4778820e996554acbb65" title="Redirect the output stream to streambuf* strbuf or ostream&amp; os. If strbuf = cout.rdbuf(), then the output is standard output. It can also redirect the output to a file by the following codes: ofstream ofile(&quot;output.txt&quot;); streambuf* oldsb = xxx.setOutput(ofile.rdbuf());  or streambuf* oldsb = xxx.setOutput(ofile); . ">setOutput</a>(streambuf* strbuf = std::cout.rdbuf()); </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00454">454</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc6fb6687d6e38b7600fac2e4c858db3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline void argumatrix::PlReasoner::printSomeExt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>predct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>argset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an ${AF}=&lt; {X}, {R}&gt;$ and an argument $s  {X}$ (respectively, a set of arguments $S {X}$), enumerate some set $E {X}$ such that $E  {E}_(AF)$ and $s E$ (respectively, $S  E$). </p>
<p>Problem [SC-$$] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>set of arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>

<p>Definition at line <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html#l00468">468</a> of file <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html">PlReasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html#l00209">task_SC()</a>, <a class="el" href="../../d6/d26/_stable_pl_reasoner_8hpp_source.html#l00202">argumatrix::StablePlReasoner::task_SC()</a>, <a class="el" href="../../d1/dff/_complete_pl_reasoner_8hpp_source.html#l00226">argumatrix::CompletePlReasoner::task_SC()</a>, <a class="el" href="../../d6/d26/_stable_pl_reasoner_8hpp_source.html#l00213">argumatrix::StablePlReasoner::task_SE()</a>, and <a class="el" href="../../d1/dff/_complete_pl_reasoner_8hpp_source.html#l00237">argumatrix::CompletePlReasoner::task_SE()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d09964e79bb4778820e996554acbb65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline streambuf * argumatrix::Reasoner::setOutput </td>
          <td>(</td>
          <td class="paramtype">streambuf *&#160;</td>
          <td class="paramname"><em>strbuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redirect the output stream to streambuf* strbuf or ostream&amp; os. If strbuf = cout.rdbuf(), then the output is standard output. It can also redirect the output to a file by the following codes: </p><div class="fragment"><div class="line">ofstream ofile(<span class="stringliteral">&quot;output.txt&quot;</span>);</div><div class="line">streambuf* oldsb = xxx.setOutput(ofile.rdbuf()); </div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line">streambuf* oldsb = xxx.setOutput(ofile); </div></div><!-- fragment --><p>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strbuf</td><td>is a streambuf pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return the old streambuf, which can be used to redirect the old streambuf. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00473">473</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf3783f1330a7fba62afd0b2953c3855"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline streambuf * argumatrix::Reasoner::setOutput </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>std::cout</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method: setOutput FullName: public <a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a2d09964e79bb4778820e996554acbb65" title="Redirect the output stream to streambuf* strbuf or ostream&amp; os. If strbuf = cout.rdbuf(), then the output is standard output. It can also redirect the output to a file by the following codes: ofstream ofile(&quot;output.txt&quot;); streambuf* oldsb = xxx.setOutput(ofile.rdbuf());  or streambuf* oldsb = xxx.setOutput(ofile); . ">argumatrix::Reasoner::setOutput</a> </p><dl class="section see"><dt>See also</dt><dd>streambuf* <a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a2d09964e79bb4778820e996554acbb65" title="Redirect the output stream to streambuf* strbuf or ostream&amp; os. If strbuf = cout.rdbuf(), then the output is standard output. It can also redirect the output to a file by the following codes: ofstream ofile(&quot;output.txt&quot;); streambuf* oldsb = xxx.setOutput(ofile.rdbuf());  or streambuf* oldsb = xxx.setOutput(ofile); . ">setOutput</a>(streambuf* strbuf = std::cout.rdbuf()); </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostream</td><td>&amp; os </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>streambuf* </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00479">479</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a99b18e3fa677f2167e9d41b24e5cc0f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline void argumatrix::AdmissiblePlReasoner::task_DC </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>argset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an $AF = &lt;X,R&gt;$ and an argument s  X (respectively, a set of arguments $S  X$). Decide whether s contained (respectively, S included) in some E  E_(AF) (i.e., credulously justified). </p>
<p>Problem [DC-$$] </p>

<p>Reimplemented from <a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#ac4ca26c438d1f97791a5645dfed2d164">argumatrix::Reasoner</a>.</p>

<p>Definition at line <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html#l00228">228</a> of file <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html">AdmissiblePlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad038b5d309cbc354de30b0c9e872a3e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline void argumatrix::AdmissiblePlReasoner::task_DE </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>argset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an $AF = &lt;X,R&gt;$ and a set of arguments $S  X$. Decide whether S is a -extension of AF, i.e., S  E_(AF). </p>
<p>Problem [DE-$$] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>set of arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if argset is a -extension; otherwise return false. </dd></dl>

<p>Reimplemented from <a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a4b0afc6a34d383c06c0c06487a38e5d0">argumatrix::Reasoner</a>.</p>

<p>Definition at line <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html#l00183">183</a> of file <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html">AdmissiblePlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab36beb291f979465c4708f056974a8b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void argumatrix::AdmissiblePlReasoner::task_DN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an $AF = &lt;X,R&gt;$ and a set of arguments $S  X$. Decide whether there exist a non-empty -extension for AF. </p>
<p>Problem [DN-$$] </p><dl class="section return"><dt>Returns</dt><dd>true if there exist a non-empty -extension; otherwise return false. </dd></dl>

<p>Reimplemented from <a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a6048e6e71916ca565f2c55aec0962894">argumatrix::Reasoner</a>.</p>

<p>Definition at line <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html#l00199">199</a> of file <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html">AdmissiblePlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac23484027cde4bbbfe2520eeda457b31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline void argumatrix::AdmissiblePlReasoner::task_DS </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>argset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an $AF = &lt;X,R&gt;$ and an argument s  X (respectively, a set of arguments $S  X$). Decide whether s contained (respectively, S included) in each E  E_(AF) (i.e., skeptically justified). </p>
<p>Problem [DS-$$] </p>

<p>Reimplemented from <a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a19f16967da79370313d5121405a3d6f1">argumatrix::Reasoner</a>.</p>

<p>Definition at line <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html#l00243">243</a> of file <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html">AdmissiblePlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad9a9a11fa7cdeb7e0278cf54ff40bf1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline void argumatrix::AdmissiblePlReasoner::task_EC </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>argset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an ${AF}=&lt; {X}, {R}&gt;$ and an argument $s  {X}$ (respectively, a set of arguments $S {X}$), enumerate all sets $E {X}$ such that $E  {E}_(AF)$ and $s E$ (respectively, $S  E$). </p>
<p>Problem [EC-$$] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set&lt;string&gt;,or</td><td>a Boolean vector: a set of argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>

<p>Reimplemented from <a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#af2c003ddab6285f34ca23328f5a80668">argumatrix::Reasoner</a>.</p>

<p>Definition at line <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html#l00166">166</a> of file <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html">AdmissiblePlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02ce5625c25c6828c9e20f9a5df6253b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline void argumatrix::AdmissiblePlReasoner::task_EE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print all extensions (with a vector of integers {0,1,2}) </p>
<p>Problem [EE-$$] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">no</td><td>argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>

<p>Reimplemented from <a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a25357765323869b260f5bef6714eb367">argumatrix::Reasoner</a>.</p>

<p>Definition at line <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html#l00160">160</a> of file <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html">AdmissiblePlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad2f647bb5cfb92172e5de80b6e07e9bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline void argumatrix::AdmissiblePlReasoner::task_SC </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>argset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an ${AF}=&lt; {X}, {R}&gt;$ and an argument $s  {X}$ (respectively, a set of arguments $S {X}$), enumerate some set $E {X}$ such that $E  {E}_(AF)$ and $s E$ (respectively, $S  E$). </p>
<p>Problem [SC-$$] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>set of arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>

<p>Reimplemented from <a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a94dc906a772eef4a4f5889c6264db086">argumatrix::Reasoner</a>.</p>

<p>Definition at line <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html#l00209">209</a> of file <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html">AdmissiblePlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc14015ec60ef03ccc50651fca51ce4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline void argumatrix::AdmissiblePlReasoner::task_SE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an ${AF}=&lt; {X}, {R}&gt;$, enumerate some set $E {X}$ that are in ${E}_(AF)$. </p>
<p>Problem [SE-$$] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>set of arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>

<p>Reimplemented from <a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#aba54122b9a2e1aad7f216079ee5c0987">argumatrix::Reasoner</a>.</p>

<p>Definition at line <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html#l00220">220</a> of file <a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html">AdmissiblePlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a11f0118ec8c837fa154b5a9fa16a24dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool argumatrix::PlReasoner::verifyExclusion </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>predct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>vecB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an $AF = &lt;X,R&gt;$ and a set of arguments $S  X$. Decide whether there exist a -extension that excludes S. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>set of arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there exist a -extension that excludes S; otherwise return false. </dd></dl>

<p>Definition at line <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html#l00576">576</a> of file <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html">PlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a61ef282f52392a19388f769737a35bfa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline bool argumatrix::PlReasoner::verifyExtension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>predct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>argset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an $AF = &lt;X,R&gt;$ and a set of arguments $S  X$. Decide whether S is a $$-extension of AF, i.e., $S  E_(AF)$. </p>
<p>Problem [DE-$$] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>set of arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if argset is a -extension; otherwise return false. </dd></dl>

<p>Definition at line <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html#l00609">609</a> of file <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html">PlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed707a454fc88e71c9c546685f4eed94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool argumatrix::PlReasoner::verifyInclusion </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>predct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecii</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an $AF = &lt;X,R&gt;$ and a set of arguments $S  X$. Decide whether there exist a -extension that includes S. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>set of arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there exist a -extension that includes S; otherwise return false. </dd></dl>

<p>Definition at line <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html#l00543">543</a> of file <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html">PlReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb2365aa2d5ed04e7f85764e0386403a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool argumatrix::PlReasoner::verifyNonemptyExt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>predct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an $AF = &lt;X,R&gt;$ and a set of arguments $S  X$. Decide whether there exist a non-empty $$-extension for AF. </p>
<p>Problem [DN-$$] </p><dl class="section return"><dt>Returns</dt><dd>true if there exist a non-empty -extension; otherwise return false. </dd></dl>

<p>Definition at line <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html#l00510">510</a> of file <a class="el" href="../../de/d5f/_pl_reasoner_8hpp_source.html">PlReasoner.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ad6776638576fce3158fef6b6d970b3d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; std::string &gt; argumatrix::Reasoner::m_argLabels</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dung's abstract argumentation framework </p>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00346">346</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00433">argumatrix::Reasoner::printLabSet()</a>.</p>

</div>
</div>
<a class="anchor" id="aef8d4a980b742479272808e2870dc957"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type argumatrix::Reasoner::m_argNum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of arguments </p>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00339">339</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00375">argumatrix::Reasoner::characteristic()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00484">argumatrix::Reasoner::getGroundedExtension()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00499">argumatrix::Reasoner::getGroundedIntVector()</a>, and <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00526">argumatrix::Reasoner::labelSet2IntVector()</a>.</p>

</div>
</div>
<a class="anchor" id="a4daaa89514c4e3335661cdf8652e64ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d64/classargumatrix_1_1bitmatrix.html">bitmatrix</a> argumatrix::Reasoner::m_BmAtkMtx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The bitmatrix of the Dung Abstract argumentation framework. We can access all attackers of an argument. The attackers of the argument with index i is m_BmAtkMtx[i]. </p>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00334">334</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00360">argumatrix::Reasoner::getAttacked()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00414">argumatrix::Reasoner::getSelfAttackingArguments()</a>, and <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00406">argumatrix::Reasoner::is_self_attacking()</a>.</p>

</div>
</div>
<a class="anchor" id="a11f4fddc89b83dfb5179c4028658c613"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d1/d62/classargumatrix_1_1_dung_a_f.html">DungAF</a>&amp; argumatrix::Reasoner::m_daf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dung's abstract argumentation framework </p>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00342">342</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00381">argumatrix::Reasoner::is_conflict_free()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00526">argumatrix::Reasoner::labelSet2IntVector()</a>, and <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00428">argumatrix::Reasoner::printBvExts()</a>.</p>

</div>
</div>
<a class="anchor" id="a0dda7c4ca8b4391d929b7f4ce14f1db1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream argumatrix::Reasoner::m_output</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Where to output </p>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00348">348</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00428">argumatrix::Reasoner::printBvExts()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00539">argumatrix::Reasoner::printGroundedExt()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00433">argumatrix::Reasoner::printLabSet()</a>, and <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00473">argumatrix::Reasoner::setOutput()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>F:/Codespace/BoostProject/argumatrix/PlReasoner/<a class="el" href="../../d4/d67/_admissible_pl_reasoner_8hpp_source.html">AdmissiblePlReasoner.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>argumatrix</b></li><li class="navelem"><a class="el" href="../../d1/d18/classargumatrix_1_1_admissible_pl_reasoner.html">AdmissiblePlReasoner</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
