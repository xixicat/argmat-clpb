<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>argmat-clpb: argumatrix::PreferredReasoner Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../logo-small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">argmat-clpb
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d7/d35/classargumatrix_1_1_preferred_reasoner.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="../../d4/d55/classargumatrix_1_1_preferred_reasoner-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">argumatrix::PreferredReasoner Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="../../d8/d49/_preferred_reasoner_8hpp_source.html">PreferredReasoner.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for argumatrix::PreferredReasoner:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../d7/d35/classargumatrix_1_1_preferred_reasoner.png" usemap="#argumatrix::PreferredReasoner_map" alt=""/>
  <map id="argumatrix::PreferredReasoner_map" name="argumatrix::PreferredReasoner_map">
<area href="../../da/d89/classargumatrix_1_1_reasoner.html" alt="argumatrix::Reasoner" shape="rect" coords="0,0,186,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6f6b5c1d0bf7e4c82ebe8c59d2a2c875"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f6b5c1d0bf7e4c82ebe8c59d2a2c875"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PreferredReasoner</b> (const <a class="el" href="../../d1/d62/classargumatrix_1_1_dung_a_f.html">DungAF</a> &amp;daf, streambuf *osbuff=std::cout.rdbuf())</td></tr>
<tr class="separator:a6f6b5c1d0bf7e4c82ebe8c59d2a2c875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d586de50476ef3f8b5dfc66153d3f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d35/classargumatrix_1_1_preferred_reasoner.html#ae9d586de50476ef3f8b5dfc66153d3f3">computeExtensions</a> ()</td></tr>
<tr class="separator:ae9d586de50476ef3f8b5dfc66153d3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135ed891d6a255478540bfc27fee0312"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d35/classargumatrix_1_1_preferred_reasoner.html#a135ed891d6a255478540bfc27fee0312">getAttackers</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;_bv)</td></tr>
<tr class="separator:a135ed891d6a255478540bfc27fee0312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8358d63da6d7bc793d923adbd0b75c8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a8358d63da6d7bc793d923adbd0b75c8f">getAttacked</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;_bv)</td></tr>
<tr class="memdesc:a8358d63da6d7bc793d923adbd0b75c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the attacked arguments by arguments in _bv, \(R^+(S)\) \(R^+(S) = {x|x is attacked by S}\). \(R^+(S_bv) = D*S_bv\).  <a href="#a8358d63da6d7bc793d923adbd0b75c8f">More...</a><br /></td></tr>
<tr class="separator:a8358d63da6d7bc793d923adbd0b75c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee95de8e7d8bdbe361c3a591fe9830e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a3ee95de8e7d8bdbe361c3a591fe9830e">characteristic</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;_bv)</td></tr>
<tr class="memdesc:a3ee95de8e7d8bdbe361c3a591fe9830e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The characteristic function of an abstract argumentation framework: \(F_{AF}(S) = {A|A is acceptable wrt. S}\). F_AF(S_bv) = not{ R^+[ not( R^+(S_bv) ) ] }.  <a href="#a3ee95de8e7d8bdbe361c3a591fe9830e">More...</a><br /></td></tr>
<tr class="separator:a3ee95de8e7d8bdbe361c3a591fe9830e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2771798ec784cd9391baf4390a9a94e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#af2771798ec784cd9391baf4390a9a94e">characteristic</a> ()</td></tr>
<tr class="memdesc:af2771798ec784cd9391baf4390a9a94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The characteristic function of an abstract argumentation framework with the initialization of empty set.  <a href="#af2771798ec784cd9391baf4390a9a94e">More...</a><br /></td></tr>
<tr class="separator:af2771798ec784cd9391baf4390a9a94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1a72e344c8fd2f2d907840549fcebf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#ace1a72e344c8fd2f2d907840549fcebf">neutrality</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;_bv)</td></tr>
<tr class="memdesc:ace1a72e344c8fd2f2d907840549fcebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The neutrality function of an abstract argumentation framework: N_AF(S) = {A| All arguments that not attacked by S}. N_AF(S_bv) = not( R^+(S_bv) )  <a href="#ace1a72e344c8fd2f2d907840549fcebf">More...</a><br /></td></tr>
<tr class="separator:ace1a72e344c8fd2f2d907840549fcebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adcecab0610f6417418c56a3980dfe6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a3adcecab0610f6417418c56a3980dfe6">is_conflict_free</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;_bv)</td></tr>
<tr class="memdesc:a3adcecab0610f6417418c56a3980dfe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument set S is conflict-free? S is said to be conflict-free iff for any two arguments a,b in S such that a does not attack b.  <a href="#a3adcecab0610f6417418c56a3980dfe6">More...</a><br /></td></tr>
<tr class="separator:a3adcecab0610f6417418c56a3980dfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a71a5e6ed451127a85fc80f91f1ca8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a71a5e6ed451127a85fc80f91f1ca8d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_conflict_free</b> (const set&lt; string &gt; &amp;argset)</td></tr>
<tr class="separator:a3a71a5e6ed451127a85fc80f91f1ca8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5b58f532ab6ebe97dd9df5bfaec750"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a6a5b58f532ab6ebe97dd9df5bfaec750">is_acceptable</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;S, const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;A)</td></tr>
<tr class="memdesc:a6a5b58f532ab6ebe97dd9df5bfaec750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument set A is acceptable w.r.t S? Alternately, S defends A? A can be an argument or an argument set. S defends argument (set) A iff for any argument x in X, if attacks A (or a in A) then there is an argument y in S such that y attacks x.  <a href="#a6a5b58f532ab6ebe97dd9df5bfaec750">More...</a><br /></td></tr>
<tr class="separator:a6a5b58f532ab6ebe97dd9df5bfaec750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847a5aee187ac032f73a671c9af92833"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a847a5aee187ac032f73a671c9af92833">is_self_attacking</a> (size_type idx)</td></tr>
<tr class="memdesc:a847a5aee187ac032f73a671c9af92833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument a is self-attacking iff it attacks itself.  <a href="#a847a5aee187ac032f73a671c9af92833">More...</a><br /></td></tr>
<tr class="separator:a847a5aee187ac032f73a671c9af92833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9ff217d7ac88b3ae98ff9709e5be0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#aed9ff217d7ac88b3ae98ff9709e5be0e">is_admissible</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;_bv)</td></tr>
<tr class="memdesc:aed9ff217d7ac88b3ae98ff9709e5be0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">To decide whether a set of arguments (with the form of bitvector) is an admissible extension. $S$ is an admissible extension iff $S  F(S)  N(S)$.  <a href="#aed9ff217d7ac88b3ae98ff9709e5be0e">More...</a><br /></td></tr>
<tr class="separator:aed9ff217d7ac88b3ae98ff9709e5be0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e190e21d8e00a26590cb4850764273"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a99e190e21d8e00a26590cb4850764273">is_complete</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;_bv)</td></tr>
<tr class="memdesc:a99e190e21d8e00a26590cb4850764273"><td class="mdescLeft">&#160;</td><td class="mdescRight">To decide whether a set of arguments (with the form of bitvector) is a complete extension. $S$ is a complete extension iff $S == F(S)  N(S)$.  <a href="#a99e190e21d8e00a26590cb4850764273">More...</a><br /></td></tr>
<tr class="separator:a99e190e21d8e00a26590cb4850764273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf96b178007b837d780237aea4beb1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#aadf96b178007b837d780237aea4beb1b">is_stable</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;_bv)</td></tr>
<tr class="memdesc:aadf96b178007b837d780237aea4beb1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">To decide whether a set of arguments (with the form of bitvector) is a stable extension. $S$ is a stable extension iff $S == N(S)$.  <a href="#aadf96b178007b837d780237aea4beb1b">More...</a><br /></td></tr>
<tr class="separator:aadf96b178007b837d780237aea4beb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31b6af53cfed1a4b3652dc509763fce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#af31b6af53cfed1a4b3652dc509763fce">is_grounded</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;_bv)</td></tr>
<tr class="memdesc:af31b6af53cfed1a4b3652dc509763fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">To decide whether a set of arguments (with the form of bitvector) is a grounded extension. $S$ is a grounded extension iff it is the least fixed point of the characteristic function F.  <a href="#af31b6af53cfed1a4b3652dc509763fce">More...</a><br /></td></tr>
<tr class="separator:af31b6af53cfed1a4b3652dc509763fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae733bcb7ab64468c08c0d0189ba6a6dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#ae733bcb7ab64468c08c0d0189ba6a6dc">getSelfAttackingArguments</a> ()</td></tr>
<tr class="memdesc:ae733bcb7ab64468c08c0d0189ba6a6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all arguments which are self-attacking. Obviously, if an argument i attacks itself, the entry[i][i] of the attack matrix must be 1 (true). Therefore to get the set of self-attacking arguments is to get the diagonal elements of the attack matrix.  <a href="#ae733bcb7ab64468c08c0d0189ba6a6dc">More...</a><br /></td></tr>
<tr class="separator:ae733bcb7ab64468c08c0d0189ba6a6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01963934038ed4cf5d407e228d38f774"><td class="memItemLeft" align="right" valign="top">const set&lt; <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a01963934038ed4cf5d407e228d38f774">getBvExtensions</a> ()</td></tr>
<tr class="memdesc:a01963934038ed4cf5d407e228d38f774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all extensions given a specific semantics in format of bitvector. Each extension is a set of arguments which can "survive the conflict
together". Here, we use a bitvector to represent an extension. Therefore, all extensions are formed an set of bit vectors, i.e., set&lt;bitvector&gt;. Each bitvector in set is an extension w.r.t. a given semantics. The computed extensions are stored in m_extensions, therefore, to get all extensions, it must first invoke the function computeExtension()  <a href="#a01963934038ed4cf5d407e228d38f774">More...</a><br /></td></tr>
<tr class="separator:a01963934038ed4cf5d407e228d38f774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e70726a3d9ec8021e18cfe46191f63"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a21e70726a3d9ec8021e18cfe46191f63">getGroundedIntVector</a> ()</td></tr>
<tr class="memdesc:a21e70726a3d9ec8021e18cfe46191f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector of integers {0, 1, 2}: 2 &ndash; Unknown, 1 &ndash; in grounded extension, and 0 &ndash; attacked by the grounded extension.  <a href="#a21e70726a3d9ec8021e18cfe46191f63">More...</a><br /></td></tr>
<tr class="separator:a21e70726a3d9ec8021e18cfe46191f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d09964e79bb4778820e996554acbb65"><td class="memItemLeft" align="right" valign="top">streambuf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a2d09964e79bb4778820e996554acbb65">setOutput</a> (streambuf *strbuf)</td></tr>
<tr class="memdesc:a2d09964e79bb4778820e996554acbb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirect the output stream to streambuf* strbuf or ostream&amp; os. If strbuf = cout.rdbuf(), then the output is standard output. It can also redirect the output to a file by the following codes: </p><div class="fragment"><div class="line">ofstream ofile(<span class="stringliteral">&quot;output.txt&quot;</span>);</div><div class="line">streambuf* oldsb = xxx.setOutput(ofile.rdbuf()); </div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line">streambuf* oldsb = xxx.setOutput(ofile); </div></div><!-- fragment --><p>.  <a href="#a2d09964e79bb4778820e996554acbb65">More...</a><br /></td></tr>
<tr class="separator:a2d09964e79bb4778820e996554acbb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3783f1330a7fba62afd0b2953c3855"><td class="memItemLeft" align="right" valign="top">streambuf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#acf3783f1330a7fba62afd0b2953c3855">setOutput</a> (ostream &amp;os=std::cout)</td></tr>
<tr class="separator:acf3783f1330a7fba62afd0b2953c3855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f980ea40699bad16a08645b71f1b5de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a9f980ea40699bad16a08645b71f1b5de">printLabSet</a> (const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;bv_ext)</td></tr>
<tr class="memdesc:a9f980ea40699bad16a08645b71f1b5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an extension with the form of bitvector. Assume the bitvector is [0, 1, 0, 1], the arguments corresponding to entry 1 will be print. The member <em>m_output</em> will determine where to print.  <a href="#a9f980ea40699bad16a08645b71f1b5de">More...</a><br /></td></tr>
<tr class="separator:a9f980ea40699bad16a08645b71f1b5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d13479a03bf2e760a227e7a47b7d54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#aa7d13479a03bf2e760a227e7a47b7d54">printLabSet</a> (const std::set&lt; string &gt; &amp;labset)</td></tr>
<tr class="memdesc:aa7d13479a03bf2e760a227e7a47b7d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a set of arguments. The member <em>m_output</em> will determine where to print.  <a href="#aa7d13479a03bf2e760a227e7a47b7d54">More...</a><br /></td></tr>
<tr class="separator:aa7d13479a03bf2e760a227e7a47b7d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9d4c09c36aaa5f6489e4a904592cc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a9a9d4c09c36aaa5f6489e4a904592cc0">printBvExts</a> ()</td></tr>
<tr class="memdesc:a9a9d4c09c36aaa5f6489e4a904592cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output all extensions given a specific semantics with an ostream. Each extension is a set of arguments which can "survive the conflict
together". Here, we return a string to represent all extensions. For example, if there are two extensions, [a,b] and [b, d], for some problem w.r.t. a given semantics, then we return string "[[a,b],[d,c]]". If extensions is not existing, the string "[]" will return.  <a href="#a9a9d4c09c36aaa5f6489e4a904592cc0">More...</a><br /></td></tr>
<tr class="separator:a9a9d4c09c36aaa5f6489e4a904592cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9586dcec7cbe8ec4d36da47fe34f21d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a9586dcec7cbe8ec4d36da47fe34f21d6">getGroundedExtension</a> ()</td></tr>
<tr class="memdesc:a9586dcec7cbe8ec4d36da47fe34f21d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the grounded extension.  <a href="#a9586dcec7cbe8ec4d36da47fe34f21d6">More...</a><br /></td></tr>
<tr class="separator:a9586dcec7cbe8ec4d36da47fe34f21d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167ee1f6201541666757fc610d9dd050"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a167ee1f6201541666757fc610d9dd050">printGroundedExt</a> ()</td></tr>
<tr class="memdesc:a167ee1f6201541666757fc610d9dd050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the grounded extension.  <a href="#a167ee1f6201541666757fc610d9dd050">More...</a><br /></td></tr>
<tr class="separator:a167ee1f6201541666757fc610d9dd050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ad3b22ab7f508695863be0279fb7cd"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#ac5ad3b22ab7f508695863be0279fb7cd">labelSet2IntVector</a> (const std::set&lt; string &gt; &amp;label_set)</td></tr>
<tr class="memdesc:ac5ad3b22ab7f508695863be0279fb7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a set of argument (string) labels to an integer vector of {0,1,2}, All arguments in these set, the indices is 1; otherwise 2 (representing unknown)  <a href="#ac5ad3b22ab7f508695863be0279fb7cd">More...</a><br /></td></tr>
<tr class="separator:ac5ad3b22ab7f508695863be0279fb7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25357765323869b260f5bef6714eb367"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a25357765323869b260f5bef6714eb367">task_EE</a> ()</td></tr>
<tr class="memdesc:a25357765323869b260f5bef6714eb367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Problem [EE-$$] Print all extensions.  <a href="#a25357765323869b260f5bef6714eb367">More...</a><br /></td></tr>
<tr class="separator:a25357765323869b260f5bef6714eb367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef66fc5e87fcd5252f8a3f4b12c9bab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ef66fc5e87fcd5252f8a3f4b12c9bab"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>task_EX</b> ()</td></tr>
<tr class="separator:a2ef66fc5e87fcd5252f8a3f4b12c9bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c003ddab6285f34ca23328f5a80668"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#af2c003ddab6285f34ca23328f5a80668">task_EC</a> (const std::set&lt; string &gt; &amp;argset)</td></tr>
<tr class="memdesc:af2c003ddab6285f34ca23328f5a80668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Problem [EC-$$] Given an ${AF}=&lt; {X}, {R}&gt;$ and an argument $s  {X}$ (respectively, a set of arguments $S {X}$), enumerate all sets $E {X}$ such that $E  {E}_(AF)$ and $s E$ (respectively, $S  E$).  <a href="#af2c003ddab6285f34ca23328f5a80668">More...</a><br /></td></tr>
<tr class="separator:af2c003ddab6285f34ca23328f5a80668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dc906a772eef4a4f5889c6264db086"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a94dc906a772eef4a4f5889c6264db086">task_SC</a> (const std::set&lt; string &gt; &amp;argset)</td></tr>
<tr class="memdesc:a94dc906a772eef4a4f5889c6264db086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Problem [SC-$$] Given an ${AF}=&lt; {X}, {R}&gt;$ and an argument $s  {X}$ (respectively, a set of arguments $S {X}$), enumerate some set $E {X}$ such that $E  {E}_(AF)$ and $s E$ (respectively, $S  E$).  <a href="#a94dc906a772eef4a4f5889c6264db086">More...</a><br /></td></tr>
<tr class="separator:a94dc906a772eef4a4f5889c6264db086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba54122b9a2e1aad7f216079ee5c0987"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#aba54122b9a2e1aad7f216079ee5c0987">task_SE</a> ()</td></tr>
<tr class="memdesc:aba54122b9a2e1aad7f216079ee5c0987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Problem [SE-$$] Given an ${AF}=&lt; {X}, {R}&gt;$, enumerate some set $E {X}$ that are in ${E}_(AF)$.  <a href="#aba54122b9a2e1aad7f216079ee5c0987">More...</a><br /></td></tr>
<tr class="separator:aba54122b9a2e1aad7f216079ee5c0987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0afc6a34d383c06c0c06487a38e5d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a4b0afc6a34d383c06c0c06487a38e5d0">task_DE</a> (const std::set&lt; string &gt; &amp;argset)</td></tr>
<tr class="memdesc:a4b0afc6a34d383c06c0c06487a38e5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Problem [DE-$$] Given an $AF = &lt;X,R&gt;$ and a set of arguments $S  X$. Decide whether S is a -extension of AF, i.e., S  E_(AF).  <a href="#a4b0afc6a34d383c06c0c06487a38e5d0">More...</a><br /></td></tr>
<tr class="separator:a4b0afc6a34d383c06c0c06487a38e5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6048e6e71916ca565f2c55aec0962894"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a6048e6e71916ca565f2c55aec0962894">task_DN</a> ()</td></tr>
<tr class="memdesc:a6048e6e71916ca565f2c55aec0962894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Problem [DN-$$] Given an $AF = &lt;X,R&gt;$ and a set of arguments $S  X$. Decide whether there exist a non-empty -extension for AF.  <a href="#a6048e6e71916ca565f2c55aec0962894">More...</a><br /></td></tr>
<tr class="separator:a6048e6e71916ca565f2c55aec0962894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ca26c438d1f97791a5645dfed2d164"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4ca26c438d1f97791a5645dfed2d164"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#ac4ca26c438d1f97791a5645dfed2d164">task_DC</a> (const std::set&lt; string &gt; &amp;argset)</td></tr>
<tr class="memdesc:ac4ca26c438d1f97791a5645dfed2d164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Problem [DC-$$] Given an $AF = &lt;X,R&gt;$ and an argument s  X (respectively, a set of arguments $S  X$). Decide whether s contained (respectively, S included) in some E  E_(AF) (i.e., credulously justified). <br /></td></tr>
<tr class="separator:ac4ca26c438d1f97791a5645dfed2d164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f16967da79370313d5121405a3d6f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19f16967da79370313d5121405a3d6f1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a19f16967da79370313d5121405a3d6f1">task_DS</a> (const std::set&lt; string &gt; &amp;argset)</td></tr>
<tr class="memdesc:a19f16967da79370313d5121405a3d6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Problem [DS-$$] Given an $AF = &lt;X,R&gt;$ and an argument s  X (respectively, a set of arguments $S  X$). Decide whether s contained (respectively, S included) in each E  E_(AF) (i.e., skeptically justified). <br /></td></tr>
<tr class="separator:a19f16967da79370313d5121405a3d6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4daaa89514c4e3335661cdf8652e64ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d64/classargumatrix_1_1bitmatrix.html">bitmatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a4daaa89514c4e3335661cdf8652e64ad">m_BmAtkMtx</a></td></tr>
<tr class="separator:a4daaa89514c4e3335661cdf8652e64ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8d4a980b742479272808e2870dc957"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#aef8d4a980b742479272808e2870dc957">m_argNum</a></td></tr>
<tr class="separator:aef8d4a980b742479272808e2870dc957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f4fddc89b83dfb5179c4028658c613"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d1/d62/classargumatrix_1_1_dung_a_f.html">DungAF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a11f4fddc89b83dfb5179c4028658c613">m_daf</a></td></tr>
<tr class="separator:a11f4fddc89b83dfb5179c4028658c613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b64952543efd9e20765015fed63d23b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b64952543efd9e20765015fed63d23b"></a>
set&lt; <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_extensions</b></td></tr>
<tr class="separator:a1b64952543efd9e20765015fed63d23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6776638576fce3158fef6b6d970b3d5"><td class="memItemLeft" align="right" valign="top">vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#ad6776638576fce3158fef6b6d970b3d5">m_argLabels</a></td></tr>
<tr class="separator:ad6776638576fce3158fef6b6d970b3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dda7c4ca8b4391d929b7f4ce14f1db1"><td class="memItemLeft" align="right" valign="top">std::ostream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a0dda7c4ca8b4391d929b7f4ce14f1db1">m_output</a></td></tr>
<tr class="separator:a0dda7c4ca8b4391d929b7f4ce14f1db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This reasoner for Dung theories performs inference on the preferred extension. Computes the (unique) grounded extension, i.e., the least fixpoint of the characteristic function. </p>

<p>Definition at line <a class="el" href="../../d8/d49/_preferred_reasoner_8hpp_source.html#l00038">38</a> of file <a class="el" href="../../d8/d49/_preferred_reasoner_8hpp_source.html">PreferredReasoner.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3ee95de8e7d8bdbe361c3a591fe9830e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">argumatrix::bitvector</a> argumatrix::Reasoner::characteristic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>_bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The characteristic function of an abstract argumentation framework: \(F_{AF}(S) = {A|A is acceptable wrt. S}\). F_AF(S_bv) = not{ R^+[ not( R^+(S_bv) ) ] }. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extension</td><td>an extension (a set of arguments), the default is empty set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a set of arguments in bitvector form. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00368">368</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2771798ec784cd9391baf4390a9a94e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">argumatrix::bitvector</a> argumatrix::Reasoner::characteristic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The characteristic function of an abstract argumentation framework with the initialization of empty set. </p>
<dl class="section return"><dt>Returns</dt><dd>a set of arguments in bitvector form. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00375">375</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00484">argumatrix::Reasoner::getGroundedExtension()</a>, and <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00394">argumatrix::Reasoner::is_acceptable()</a>.</p>

</div>
</div>
<a class="anchor" id="ae9d586de50476ef3f8b5dfc66153d3f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void argumatrix::PreferredReasoner::computeExtensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute all extensions given a specific semantics. Each extension is a set of arguments. Here, we use a bitvector to represent an extension. The results are stored in m_extensions. When a new extension bv is computed, it can be added to m_extensions by m_extensions.push_back(bv). </p><dl class="section return"><dt>Returns</dt><dd>no return. The results are stored in m_extensions. </dd></dl>

<p>Definition at line <a class="el" href="../../d8/d49/_preferred_reasoner_8hpp_source.html#l00097">97</a> of file <a class="el" href="../../d8/d49/_preferred_reasoner_8hpp_source.html">PreferredReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8358d63da6d7bc793d923adbd0b75c8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">argumatrix::bitvector</a> argumatrix::Reasoner::getAttacked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>_bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the attacked arguments by arguments in _bv, \(R^+(S)\) \(R^+(S) = {x|x is attacked by S}\). \(R^+(S_bv) = D*S_bv\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_bv</td><td>the bitvector with respect to the set \(S\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a set of arguments in bitvector form. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00360">360</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00499">argumatrix::Reasoner::getGroundedIntVector()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00381">argumatrix::Reasoner::is_conflict_free()</a>, and <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00547">argumatrix::Reasoner::neutrality()</a>.</p>

</div>
</div>
<a class="anchor" id="a135ed891d6a255478540bfc27fee0312"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> argumatrix::PreferredReasoner::getAttackers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>_bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get attackers of arguments in _bv, R^-(S) R^-(S) = {x|x attacks some argument in S}. R^-(S_bv) = D^T*S_bv </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_bv</td><td>the bitvector of a set of arguments S. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a set of arguments in bitvector form. </dd></dl>

<p>Definition at line <a class="el" href="../../d8/d49/_preferred_reasoner_8hpp_source.html#l00246">246</a> of file <a class="el" href="../../d8/d49/_preferred_reasoner_8hpp_source.html">PreferredReasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a01963934038ed4cf5d407e228d38f774"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline const set&lt; <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &gt; &amp; argumatrix::Reasoner::getBvExtensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all extensions given a specific semantics in format of bitvector. Each extension is a set of arguments which can "survive the conflict
together". Here, we use a bitvector to represent an extension. Therefore, all extensions are formed an set of bit vectors, i.e., set&lt;bitvector&gt;. Each bitvector in set is an extension w.r.t. a given semantics. The computed extensions are stored in m_extensions, therefore, to get all extensions, it must first invoke the function computeExtension() </p>
<dl class="section return"><dt>Returns</dt><dd>a set of bitvector, i.e., set&lt;bitvector&gt;. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00400">400</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9586dcec7cbe8ec4d36da47fe34f21d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">argumatrix::bitvector</a> argumatrix::Reasoner::getGroundedExtension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the grounded extension. </p>
<dl class="section return"><dt>Returns</dt><dd>a set of arguments in bitvector form. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00484">484</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00584">argumatrix::Reasoner::is_grounded()</a>, and <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00539">argumatrix::Reasoner::printGroundedExt()</a>.</p>

</div>
</div>
<a class="anchor" id="a21e70726a3d9ec8021e18cfe46191f63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; argumatrix::Reasoner::getGroundedIntVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a vector of integers {0, 1, 2}: 2 &ndash; Unknown, 1 &ndash; in grounded extension, and 0 &ndash; attacked by the grounded extension. </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of integers {0, 1, 2}. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00499">499</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae733bcb7ab64468c08c0d0189ba6a6dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">argumatrix::bitvector</a> argumatrix::Reasoner::getSelfAttackingArguments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all arguments which are self-attacking. Obviously, if an argument i attacks itself, the entry[i][i] of the attack matrix must be 1 (true). Therefore to get the set of self-attacking arguments is to get the diagonal elements of the attack matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>a set of arguments in bitvector form, if bitvector[i] = true representing the argument (with index) i is a self-attacking argument, otherwise is not. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00414">414</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6a5b58f532ab6ebe97dd9df5bfaec750"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline bool argumatrix::Reasoner::is_acceptable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Argument set A is acceptable w.r.t S? Alternately, S defends A? A can be an argument or an argument set. S defends argument (set) A iff for any argument x in X, if attacks A (or a in A) then there is an argument y in S such that y attacks x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>a set of arguments. </td></tr>
    <tr><td class="paramname">A</td><td>an argument or an argument set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if S defends A. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00394">394</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed9ff217d7ac88b3ae98ff9709e5be0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline bool argumatrix::Reasoner::is_admissible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>_bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To decide whether a set of arguments (with the form of bitvector) is an admissible extension. $S$ is an admissible extension iff $S  F(S)  N(S)$. </p>
<dl class="section return"><dt>Returns</dt><dd>true if _bv is admissible; otherwise returns false. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00553">553</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a99e190e21d8e00a26590cb4850764273"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline bool argumatrix::Reasoner::is_complete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>_bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To decide whether a set of arguments (with the form of bitvector) is a complete extension. $S$ is a complete extension iff $S == F(S)  N(S)$. </p>
<dl class="section return"><dt>Returns</dt><dd>true if _bv is complete; otherwise returns false. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00564">564</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3adcecab0610f6417418c56a3980dfe6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline bool argumatrix::Reasoner::is_conflict_free </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>_bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Argument set S is conflict-free? S is said to be conflict-free iff for any two arguments a,b in S such that a does not attack b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extension</td><td>an extension (a set of arguments). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if S is conflict-free. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00381">381</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af31b6af53cfed1a4b3652dc509763fce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline bool argumatrix::Reasoner::is_grounded </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>_bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To decide whether a set of arguments (with the form of bitvector) is a grounded extension. $S$ is a grounded extension iff it is the least fixed point of the characteristic function F. </p>
<dl class="section return"><dt>Returns</dt><dd>true if _bv is grounded; otherwise returns false. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00584">584</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a847a5aee187ac032f73a671c9af92833"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline bool argumatrix::Reasoner::is_self_attacking </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Argument a is self-attacking iff it attacks itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the index of the argument w.r.t the attack matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if S defends A. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00406">406</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aadf96b178007b837d780237aea4beb1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline bool argumatrix::Reasoner::is_stable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>_bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To decide whether a set of arguments (with the form of bitvector) is a stable extension. $S$ is a stable extension iff $S == N(S)$. </p>
<dl class="section return"><dt>Returns</dt><dd>true if _bv is stable; otherwise returns false. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00575">575</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5ad3b22ab7f508695863be0279fb7cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; argumatrix::Reasoner::labelSet2IntVector </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>label_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a set of argument (string) labels to an integer vector of {0,1,2}, All arguments in these set, the indices is 1; otherwise 2 (representing unknown) </p>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00526">526</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace1a72e344c8fd2f2d907840549fcebf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">argumatrix::bitvector</a> argumatrix::Reasoner::neutrality </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>_bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The neutrality function of an abstract argumentation framework: N_AF(S) = {A| All arguments that not attacked by S}. N_AF(S_bv) = not( R^+(S_bv) ) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extension</td><td>an extension (a set of arguments). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a set of arguments in bitvector form. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00547">547</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00368">argumatrix::Reasoner::characteristic()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00499">argumatrix::Reasoner::getGroundedIntVector()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00553">argumatrix::Reasoner::is_admissible()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00564">argumatrix::Reasoner::is_complete()</a>, and <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00575">argumatrix::Reasoner::is_stable()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a9d4c09c36aaa5f6489e4a904592cc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline void argumatrix::Reasoner::printBvExts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output all extensions given a specific semantics with an ostream. Each extension is a set of arguments which can "survive the conflict
together". Here, we return a string to represent all extensions. For example, if there are two extensions, [a,b] and [b, d], for some problem w.r.t. a given semantics, then we return string "[[a,b],[d,c]]". If extensions is not existing, the string "[]" will return. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostream&amp;</td><td>os = std::cout, output the resluts into the ostream os. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a set of bitvector, i.e., set&lt;bitvector&gt;. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00428">428</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a167ee1f6201541666757fc610d9dd050"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline void argumatrix::Reasoner::printGroundedExt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the grounded extension. </p>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00539">539</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f980ea40699bad16a08645b71f1b5de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void argumatrix::Reasoner::printLabSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d5c/classargumatrix_1_1bitvector.html">bitvector</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_ext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an extension with the form of bitvector. Assume the bitvector is [0, 1, 0, 1], the arguments corresponding to entry 1 will be print. The member <em>m_output</em> will determine where to print. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitvector&amp;</td><td>bv_ext : The bv_ext is a bitvector, which represents an extension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>[<a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a2d09964e79bb4778820e996554acbb65" title="Redirect the output stream to streambuf* strbuf or ostream&amp; os. If strbuf = cout.rdbuf(), then the output is standard output. It can also redirect the output to a file by the following codes: ofstream ofile(&quot;output.txt&quot;); streambuf* oldsb = xxx.setOutput(ofile.rdbuf());  or streambuf* oldsb = xxx.setOutput(ofile); . ">setOutput</a>] </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00433">433</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00539">argumatrix::Reasoner::printGroundedExt()</a>.</p>

</div>
</div>
<a class="anchor" id="aa7d13479a03bf2e760a227e7a47b7d54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void argumatrix::Reasoner::printLabSet </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>labset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a set of arguments. The member <em>m_output</em> will determine where to print. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>std::set&lt;string&gt;&amp; labset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a2d09964e79bb4778820e996554acbb65" title="Redirect the output stream to streambuf* strbuf or ostream&amp; os. If strbuf = cout.rdbuf(), then the output is standard output. It can also redirect the output to a file by the following codes: ofstream ofile(&quot;output.txt&quot;); streambuf* oldsb = xxx.setOutput(ofile.rdbuf());  or streambuf* oldsb = xxx.setOutput(ofile); . ">setOutput</a>(streambuf* strbuf = std::cout.rdbuf()); </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00454">454</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d09964e79bb4778820e996554acbb65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline streambuf * argumatrix::Reasoner::setOutput </td>
          <td>(</td>
          <td class="paramtype">streambuf *&#160;</td>
          <td class="paramname"><em>strbuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redirect the output stream to streambuf* strbuf or ostream&amp; os. If strbuf = cout.rdbuf(), then the output is standard output. It can also redirect the output to a file by the following codes: </p><div class="fragment"><div class="line">ofstream ofile(<span class="stringliteral">&quot;output.txt&quot;</span>);</div><div class="line">streambuf* oldsb = xxx.setOutput(ofile.rdbuf()); </div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line">streambuf* oldsb = xxx.setOutput(ofile); </div></div><!-- fragment --><p>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strbuf</td><td>is a streambuf pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return the old streambuf, which can be used to redirect the old streambuf. </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00473">473</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf3783f1330a7fba62afd0b2953c3855"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__inline streambuf * argumatrix::Reasoner::setOutput </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>std::cout</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method: setOutput FullName: public <a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a2d09964e79bb4778820e996554acbb65" title="Redirect the output stream to streambuf* strbuf or ostream&amp; os. If strbuf = cout.rdbuf(), then the output is standard output. It can also redirect the output to a file by the following codes: ofstream ofile(&quot;output.txt&quot;); streambuf* oldsb = xxx.setOutput(ofile.rdbuf());  or streambuf* oldsb = xxx.setOutput(ofile); . ">argumatrix::Reasoner::setOutput</a> </p><dl class="section see"><dt>See also</dt><dd>streambuf* <a class="el" href="../../da/d89/classargumatrix_1_1_reasoner.html#a2d09964e79bb4778820e996554acbb65" title="Redirect the output stream to streambuf* strbuf or ostream&amp; os. If strbuf = cout.rdbuf(), then the output is standard output. It can also redirect the output to a file by the following codes: ofstream ofile(&quot;output.txt&quot;); streambuf* oldsb = xxx.setOutput(ofile.rdbuf());  or streambuf* oldsb = xxx.setOutput(ofile); . ">setOutput</a>(streambuf* strbuf = std::cout.rdbuf()); </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostream</td><td>&amp; os </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>streambuf* </dd></dl>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00479">479</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b0afc6a34d383c06c0c06487a38e5d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void argumatrix::Reasoner::task_DE </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>argset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Problem [DE-$$] Given an $AF = &lt;X,R&gt;$ and a set of arguments $S  X$. Decide whether S is a -extension of AF, i.e., S  E_(AF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>set of arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if argset is a -extension; otherwise return false. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For this task, the <em>set&lt;string&gt;&amp; argset</em> can be empty, which means to decide whether the empty set is a $$-extension of AF. This indicates that the option -a is not necessary, then the default <em>set&lt;string&gt;&amp; argset</em> is empty. </dd></dl>

<p>Reimplemented in <a class="el" href="../../d6/deb/classargumatrix_1_1_complete_pl_reasoner.html#afae22b5448d2c5a3a3a68dc8276c9c1a">argumatrix::CompletePlReasoner</a>, <a class="el" href="../../d3/d5b/classargumatrix_1_1_conflictfree_pl_reasoner.html#a98c8903ad7bf3ba0af7aeadf461171b5">argumatrix::ConflictfreePlReasoner</a>, <a class="el" href="../../d1/d18/classargumatrix_1_1_admissible_pl_reasoner.html#ad038b5d309cbc354de30b0c9e872a3e0">argumatrix::AdmissiblePlReasoner</a>, <a class="el" href="../../d4/d8e/classargumatrix_1_1_stable_pl_reasoner.html#a004fea34ed7d05e3b840b1dcd36dac48">argumatrix::StablePlReasoner</a>, and <a class="el" href="../../d8/d1d/classargumatrix_1_1_grounded_reasoner.html#acc0bfb0c2cb61f09419a4684a6b7ce5e">argumatrix::GroundedReasoner</a>.</p>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00303">303</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6048e6e71916ca565f2c55aec0962894"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void argumatrix::Reasoner::task_DN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Problem [DN-$$] Given an $AF = &lt;X,R&gt;$ and a set of arguments $S  X$. Decide whether there exist a non-empty -extension for AF. </p>
<dl class="section return"><dt>Returns</dt><dd>true if there exist a non-empty -extension; otherwise return false. </dd></dl>

<p>Reimplemented in <a class="el" href="../../d6/deb/classargumatrix_1_1_complete_pl_reasoner.html#a33b48978ac45361f44f6dc9d849bd74b">argumatrix::CompletePlReasoner</a>, <a class="el" href="../../d3/d5b/classargumatrix_1_1_conflictfree_pl_reasoner.html#ad7d3cb69238f55f0108b6da6dcef885d">argumatrix::ConflictfreePlReasoner</a>, <a class="el" href="../../d1/d18/classargumatrix_1_1_admissible_pl_reasoner.html#ab36beb291f979465c4708f056974a8b1">argumatrix::AdmissiblePlReasoner</a>, <a class="el" href="../../d4/d8e/classargumatrix_1_1_stable_pl_reasoner.html#ad4a925c4ef0c144273381501932a3c2f">argumatrix::StablePlReasoner</a>, and <a class="el" href="../../d8/d1d/classargumatrix_1_1_grounded_reasoner.html#a9bb48c57600c7afa883a5033de4f6491">argumatrix::GroundedReasoner</a>.</p>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00313">313</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2c003ddab6285f34ca23328f5a80668"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void argumatrix::Reasoner::task_EC </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>argset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Problem [EC-$$] Given an ${AF}=&lt; {X}, {R}&gt;$ and an argument $s  {X}$ (respectively, a set of arguments $S {X}$), enumerate all sets $E {X}$ such that $E  {E}_(AF)$ and $s E$ (respectively, $S  E$). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set&lt;string&gt;,or</td><td>a Boolean vector: a set of argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>

<p>Reimplemented in <a class="el" href="../../d6/deb/classargumatrix_1_1_complete_pl_reasoner.html#a1348e0efed9892a11c3bf1ead43e615f">argumatrix::CompletePlReasoner</a>, <a class="el" href="../../d1/d18/classargumatrix_1_1_admissible_pl_reasoner.html#ad9a9a11fa7cdeb7e0278cf54ff40bf1e">argumatrix::AdmissiblePlReasoner</a>, <a class="el" href="../../d3/d5b/classargumatrix_1_1_conflictfree_pl_reasoner.html#a4c0985505f126afd0ceb8aed679a74d0">argumatrix::ConflictfreePlReasoner</a>, <a class="el" href="../../d4/d8e/classargumatrix_1_1_stable_pl_reasoner.html#a0d9c658f3bd5918931d27460a540262c">argumatrix::StablePlReasoner</a>, and <a class="el" href="../../d8/d1d/classargumatrix_1_1_grounded_reasoner.html#a07a9faacac4d757d4a18ab731bfdd148">argumatrix::GroundedReasoner</a>.</p>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00267">267</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a25357765323869b260f5bef6714eb367"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void argumatrix::Reasoner::task_EE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Problem [EE-$$] Print all extensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">no</td><td>argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>

<p>Reimplemented in <a class="el" href="../../d6/deb/classargumatrix_1_1_complete_pl_reasoner.html#a40f8eb645d17693867aa71bfba2e37d4">argumatrix::CompletePlReasoner</a>, <a class="el" href="../../d1/d18/classargumatrix_1_1_admissible_pl_reasoner.html#a02ce5625c25c6828c9e20f9a5df6253b">argumatrix::AdmissiblePlReasoner</a>, <a class="el" href="../../d3/d5b/classargumatrix_1_1_conflictfree_pl_reasoner.html#aa84be346b1c285c3e56b0008fe8ec81c">argumatrix::ConflictfreePlReasoner</a>, <a class="el" href="../../d4/d8e/classargumatrix_1_1_stable_pl_reasoner.html#a7aaeaf025fc80a4373542fbdfbabb582">argumatrix::StablePlReasoner</a>, and <a class="el" href="../../d8/d1d/classargumatrix_1_1_grounded_reasoner.html#af6146795c4008f026fbf0a725456977e">argumatrix::GroundedReasoner</a>.</p>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00254">254</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a94dc906a772eef4a4f5889c6264db086"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void argumatrix::Reasoner::task_SC </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>argset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Problem [SC-$$] Given an ${AF}=&lt; {X}, {R}&gt;$ and an argument $s  {X}$ (respectively, a set of arguments $S {X}$), enumerate some set $E {X}$ such that $E  {E}_(AF)$ and $s E$ (respectively, $S  E$). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>set of arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>

<p>Reimplemented in <a class="el" href="../../d6/deb/classargumatrix_1_1_complete_pl_reasoner.html#a4f573fdcc5704d25c29ba63eb70a7774">argumatrix::CompletePlReasoner</a>, <a class="el" href="../../d1/d18/classargumatrix_1_1_admissible_pl_reasoner.html#ad2f647bb5cfb92172e5de80b6e07e9bd">argumatrix::AdmissiblePlReasoner</a>, <a class="el" href="../../d3/d5b/classargumatrix_1_1_conflictfree_pl_reasoner.html#ab404076d623ed6f4c1144ceb5c19753e">argumatrix::ConflictfreePlReasoner</a>, <a class="el" href="../../d4/d8e/classargumatrix_1_1_stable_pl_reasoner.html#ada7f34d32876d60fd09ffdab954fd482">argumatrix::StablePlReasoner</a>, and <a class="el" href="../../d8/d1d/classargumatrix_1_1_grounded_reasoner.html#aa2774f10424caa349756f09aa61ca9e2">argumatrix::GroundedReasoner</a>.</p>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00280">280</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba54122b9a2e1aad7f216079ee5c0987"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void argumatrix::Reasoner::task_SE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Problem [SE-$$] Given an ${AF}=&lt; {X}, {R}&gt;$, enumerate some set $E {X}$ that are in ${E}_(AF)$. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>set of arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return. </dd></dl>

<p>Reimplemented in <a class="el" href="../../d6/deb/classargumatrix_1_1_complete_pl_reasoner.html#adf4afcd428e5af5e6652f18db227f955">argumatrix::CompletePlReasoner</a>, <a class="el" href="../../d1/d18/classargumatrix_1_1_admissible_pl_reasoner.html#abc14015ec60ef03ccc50651fca51ce4d">argumatrix::AdmissiblePlReasoner</a>, <a class="el" href="../../d3/d5b/classargumatrix_1_1_conflictfree_pl_reasoner.html#a9497445dc1f937066e55093441a0abb0">argumatrix::ConflictfreePlReasoner</a>, <a class="el" href="../../d4/d8e/classargumatrix_1_1_stable_pl_reasoner.html#a773448aa1212654f07caa03d92e31565">argumatrix::StablePlReasoner</a>, and <a class="el" href="../../d8/d1d/classargumatrix_1_1_grounded_reasoner.html#a442be616c0246436e9eb870319ff7edf">argumatrix::GroundedReasoner</a>.</p>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00290">290</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ad6776638576fce3158fef6b6d970b3d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; std::string &gt; argumatrix::Reasoner::m_argLabels</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dung's abstract argumentation framework </p>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00346">346</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00433">argumatrix::Reasoner::printLabSet()</a>.</p>

</div>
</div>
<a class="anchor" id="aef8d4a980b742479272808e2870dc957"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type argumatrix::Reasoner::m_argNum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of arguments </p>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00339">339</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00375">argumatrix::Reasoner::characteristic()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00484">argumatrix::Reasoner::getGroundedExtension()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00499">argumatrix::Reasoner::getGroundedIntVector()</a>, and <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00526">argumatrix::Reasoner::labelSet2IntVector()</a>.</p>

</div>
</div>
<a class="anchor" id="a4daaa89514c4e3335661cdf8652e64ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d64/classargumatrix_1_1bitmatrix.html">bitmatrix</a> argumatrix::Reasoner::m_BmAtkMtx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The bitmatrix of the Dung Abstract argumentation framework. We can access all attackers of an argument. The attackers of the argument with index i is m_BmAtkMtx[i]. </p>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00334">334</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00360">argumatrix::Reasoner::getAttacked()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00414">argumatrix::Reasoner::getSelfAttackingArguments()</a>, and <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00406">argumatrix::Reasoner::is_self_attacking()</a>.</p>

</div>
</div>
<a class="anchor" id="a11f4fddc89b83dfb5179c4028658c613"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d1/d62/classargumatrix_1_1_dung_a_f.html">DungAF</a>&amp; argumatrix::Reasoner::m_daf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dung's abstract argumentation framework </p>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00342">342</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00381">argumatrix::Reasoner::is_conflict_free()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00526">argumatrix::Reasoner::labelSet2IntVector()</a>, and <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00428">argumatrix::Reasoner::printBvExts()</a>.</p>

</div>
</div>
<a class="anchor" id="a0dda7c4ca8b4391d929b7f4ce14f1db1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream argumatrix::Reasoner::m_output</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Where to output </p>

<p>Definition at line <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00348">348</a> of file <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html">Reasoner.hpp</a>.</p>

<p>Referenced by <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00428">argumatrix::Reasoner::printBvExts()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00539">argumatrix::Reasoner::printGroundedExt()</a>, <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00433">argumatrix::Reasoner::printLabSet()</a>, and <a class="el" href="../../db/d2f/_reasoner_8hpp_source.html#l00473">argumatrix::Reasoner::setOutput()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>F:/Codespace/BoostProject/argumatrix/dung_theory/<a class="el" href="../../d8/d49/_preferred_reasoner_8hpp_source.html">PreferredReasoner.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>argumatrix</b></li><li class="navelem"><a class="el" href="../../d7/d35/classargumatrix_1_1_preferred_reasoner.html">PreferredReasoner</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
